[START]
// File: src/main/java/com/example/sales/service/AdminUserService.java
package com.example.sales.service;

import com.example.sales.constant.ApiCode;
import com.example.sales.exception.ResourceNotFoundException;
import com.example.sales.model.User;
import com.example.sales.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class AdminUserService {

    private final UserRepository userRepository;
    private final AuditLogService auditLogService;

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }

    public User getUserById(String id) {
        return userRepository.findByIdAndDeletedFalse(id)
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.USER_NOT_FOUND));
    }

    public User updateUser(String id, User update) {
        User user = getUserById(id);
        user.setEmail(update.getEmail());
        user.setFullName(update.getFullName());
        user.setPhone(update.getPhone());
        user.setBusinessType(update.getBusinessType());
        user.setVerified(update.isVerified());
        user.setRole(update.getRole());
        return userRepository.save(user);
    }

    public void deleteUser(String userId) {
        User user = userRepository.findByIdAndDeletedFalse(userId)
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.USER_NOT_FOUND));
        user.setDeleted(true);
        userRepository.save(user);
        auditLogService.log(null, user.getId(), user.getId(), "USER", "DELETED", "Xoá mềm tài khoản người dùng");
    }
}

// File: src/main/java/com/example/sales/service/AuditLogService.java
package com.example.sales.service;

import com.example.sales.model.AuditLog;
import com.example.sales.repository.AuditLogRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AuditLogService {

    private final AuditLogRepository auditLogRepository;

    public void log(String userId, String shopId, String targetId, String targetType, String action, String description) {
        AuditLog log = AuditLog.builder()
                .userId(userId)
                .shopId(shopId)
                .targetId(targetId)
                .targetType(targetType)
                .action(action)
                .description(description)
                .build();

        auditLogRepository.save(log);
    }
}

// File: src/main/java/com/example/sales/service/AuthService.java
package com.example.sales.service;

import com.example.sales.constant.ApiCode;
import com.example.sales.dto.JwtResponse;
import com.example.sales.dto.LoginRequest;
import com.example.sales.dto.RegisterRequest;
import com.example.sales.exception.BusinessException;
import com.example.sales.exception.ResourceNotFoundException;
import com.example.sales.model.User;
import com.example.sales.repository.UserRepository;
import com.example.sales.security.JwtUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.Date;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class AuthService {

    private final UserRepository userRepository;
    private final JwtUtil jwtUtil;
    private final PasswordEncoder passwordEncoder;
    private final AuthenticationManager authenticationManager;
    private final MailService mailService;
    private final TokenService tokenService;

    @Value("${app.frontend.verify-url}")
    private String verifyUrl;

    public void register(RegisterRequest request) {
        if (userRepository.findByEmailAndDeletedFalse(request.getEmail()).isPresent()) {
            throw new BusinessException(ApiCode.EMAIL_EXISTS);
        }

        User user = new User();
        user.setEmail(request.getEmail());
        user.setPassword(passwordEncoder.encode(request.getPassword()));

        String token = UUID.randomUUID().toString();
        user.setVerificationToken(token);
        user.setVerificationExpiry(new Date(System.currentTimeMillis() + 15 * 60 * 1000));
        user.setVerified(false);

        userRepository.save(user);

        String verifyLink = verifyUrl + "?token=" + token;
        String html = "<p>Xin chào,</p>" +
                "<p>Vui lòng xác thực tài khoản của bạn bằng cách nhấn vào liên kết bên dưới:</p>" +
                "<a href=\"" + verifyLink + "\">Xác thực tài khoản</a>" +
                "<p><i>Liên kết này sẽ hết hạn sau 15 phút.</i></p>";

        mailService.send(user.getEmail(), "Xác thực tài khoản - Sandro Sales", html);
    }


    public JwtResponse login(LoginRequest request) {
        // 1. Xác thực tài khoản và mật khẩu
        authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(request.getEmail(), request.getPassword())
        );
        // 2. Lấy user từ DB
        User user = userRepository.findByEmailAndDeletedFalse(request.getEmail())
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.USER_NOT_FOUND));
        // 3. Kiểm tra đã xác thực chưa
        if (!user.isVerified()) {
            throw new BusinessException(ApiCode.EMAIL_NOT_VERIFIED);
        }
        String accessToken = jwtUtil.generateToken(user);
        String refreshToken = tokenService.createRefreshToken(user).getToken();
        return new JwtResponse(accessToken, refreshToken);
    }

    public void forgotPassword(String email) {
        User user = userRepository.findByEmailAndDeletedFalse(email)
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.USER_NOT_FOUND));

        String token = UUID.randomUUID().toString();
        user.setResetToken(token);
        user.setResetTokenExpiry(new Date(System.currentTimeMillis() + 15 * 60 * 1000)); // 15 phút
        userRepository.save(user);

        System.out.println("Gửi email tới " + email + ": Token đặt lại mật khẩu: " + token);
    }

    public void resendVerification(String email) {
        User user = userRepository.findByEmailAndDeletedFalse(email)
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.USER_NOT_FOUND));

        if (user.isVerified()) {
            throw new BusinessException(ApiCode.ALREADY_VERIFIED);
        }

        // Tạo token mới và cập nhật expiry
        String newToken = UUID.randomUUID().toString();
        user.setVerificationToken(newToken);
        user.setVerificationExpiry(new Date(System.currentTimeMillis() + 15 * 60 * 1000));

        userRepository.save(user);

        String verifyLink = verifyUrl + "?token=" + newToken;

        String html = "<p>Xin chào,</p>" +
                "<p>Bạn đã yêu cầu gửi lại email xác thực tài khoản.</p>" +
                "<p>Vui lòng xác thực tài khoản của bạn bằng cách nhấn vào liên kết bên dưới:</p>" +
                "<a href=\"" + verifyLink + "\">Xác thực tài khoản</a>" +
                "<p><i>Liên kết này sẽ hết hạn sau 15 phút.</i></p>";

        mailService.send(user.getEmail(), "Gửi lại xác thực tài khoản - Sandro Sales", html);
    }

    public void verifyEmail(String token) {
        User user = userRepository.findByVerificationTokenAndDeletedFalse(token)
                .orElseThrow(() -> new BusinessException(ApiCode.INVALID_TOKEN));

        if (user.isVerified()) {
            throw new BusinessException(ApiCode.ALREADY_VERIFIED);
        }

        if (user.getVerificationExpiry().before(new Date())) {
            throw new BusinessException(ApiCode.TOKEN_EXPIRED);
        }

        user.setVerified(true);
        user.setVerificationToken(null);
        user.setVerificationExpiry(null);
        userRepository.save(user);
    }

}

// File: src/main/java/com/example/sales/service/BaseService.java
package com.example.sales.service;

import com.example.sales.constant.ApiCode;
import com.example.sales.exception.BusinessException;
import com.example.sales.exception.ResourceNotFoundException;
import com.example.sales.model.Order;
import com.example.sales.model.Shop;
import com.example.sales.model.ShopUser;
import com.example.sales.repository.OrderRepository;
import com.example.sales.repository.ShopRepository;
import com.example.sales.repository.ShopUserRepository;

public abstract class BaseService {
    protected Shop checkShopExists(ShopRepository shopRepository, String shopId) {
        return shopRepository.findByIdAndDeletedFalse(shopId)
                .orElseThrow(() -> new BusinessException(ApiCode.SHOP_NOT_FOUND));
    }
    protected ShopUser checkShopUserExists(ShopUserRepository shopUserRepository, String shopId, String userId) {
        return shopUserRepository.findByShopIdAndUserIdAndDeletedFalse(shopId, userId)
                .orElseThrow(() -> new BusinessException(ApiCode.NOT_FOUND));
    }
    protected Order checkOrderExists(OrderRepository orderRepository, String orderId, String shopId) {
        return orderRepository.findByIdAndDeletedFalse(orderId)
                .filter(o -> o.getShopId().equals(shopId))
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.ORDER_NOT_FOUND));
    }
}

// File: src/main/java/com/example/sales/service/BranchService.java
package com.example.sales.service;

import com.example.sales.constant.ApiCode;
import com.example.sales.dto.branch.BranchRequest;
import com.example.sales.dto.branch.BranchResponse;
import com.example.sales.exception.BusinessException;
import com.example.sales.exception.ResourceNotFoundException;
import com.example.sales.model.Branch;
import com.example.sales.repository.BranchRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class BranchService {

    private final BranchRepository branchRepository;
    private final AuditLogService auditLogService;

    public Page<BranchResponse> getAll(String userId, String shopId, Pageable pageable) {
        return branchRepository.findByShopIdAndDeletedFalse(shopId, pageable)
                .map(this::toResponse);
    }

    public BranchResponse create(String userId, String shopId, BranchRequest req) {
        Branch branch = Branch.builder()
                .shopId(shopId)
                .name(req.getName())
                .address(req.getAddress())
                .phone(req.getPhone())
                .active(req.isActive())
                .build();

        Branch saved = branchRepository.save(branch);
        auditLogService.log(userId, shopId, saved.getId(), "BRANCH", "CREATED",
                String.format("Tạo chi nhánh: %s - %s", saved.getName(), saved.getAddress()));
        return toResponse(saved);
    }

    public BranchResponse update(String userId, String shopId, String id, BranchRequest req) {
        Branch branch = branchRepository.findByIdAndDeletedFalse(id)
                .filter(b -> b.getShopId().equals(shopId))
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.BRANCH_NOT_FOUND));

        branch.setName(req.getName());
        branch.setAddress(req.getAddress());
        branch.setPhone(req.getPhone());
        branch.setActive(req.isActive());

        Branch saved = branchRepository.save(branch);
        auditLogService.log(userId, shopId, saved.getId(), "BRANCH", "UPDATED",
                String.format("Cập nhật chi nhánh: %s - %s", saved.getName(), saved.getAddress()));
        return toResponse(saved);
    }

    public void delete(String userId, String shopId, String id) {
        long branchCount = branchRepository.countByShopIdAndDeletedFalse(shopId);
        if (branchCount <= 1) {
            throw new BusinessException(ApiCode.CANNOT_DELETE_ONLY_BRANCH);
        }

        Branch branch = branchRepository.findByIdAndDeletedFalse(id)
                .filter(b -> b.getShopId().equals(shopId))
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.BRANCH_NOT_FOUND));

        branch.setDeleted(true);
        branchRepository.save(branch);
        auditLogService.log(userId, shopId, branch.getId(), "BRANCH", "DELETED",
                String.format("Xoá mềm chi nhánh: %s - %s", branch.getName(), branch.getAddress()));
    }

    private BranchResponse toResponse(Branch branch) {
        return BranchResponse.builder()
                .id(branch.getId())
                .name(branch.getName())
                .address(branch.getAddress())
                .phone(branch.getPhone())
                .active(branch.isActive())
                .createdAt(branch.getCreatedAt() != null ? branch.getCreatedAt().toString() : null)
                .build();
    }
}

// File: src/main/java/com/example/sales/service/CustomerService.java
package com.example.sales.service;

import com.example.sales.constant.ApiCode;
import com.example.sales.dto.customer.CustomerRequest;
import com.example.sales.dto.customer.CustomerResponse;
import com.example.sales.exception.BusinessException;
import com.example.sales.exception.ResourceNotFoundException;
import com.example.sales.model.Customer;
import com.example.sales.repository.CustomerRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class CustomerService {

    private final CustomerRepository customerRepository;
    private final AuditLogService auditLogService;

    public List<CustomerResponse> getCustomers(String shopId, String branchId) {
        return customerRepository.findByShopIdAndBranchIdAndDeletedFalse(shopId, branchId)
                .stream()
                .map(this::toResponse)
                .toList();
    }

    public CustomerResponse createCustomer(String shopId, String userId, CustomerRequest request) {
        Customer customer = new Customer();
        customer.setShopId(shopId);
        customer.setUserId(userId);
        customer.setName(request.getName());
        customer.setPhone(request.getPhone());
        customer.setEmail(request.getEmail());
        customer.setAddress(request.getAddress());
        customer.setNote(request.getNote());
        customer.setBranchId(request.getBranchId());

        Customer saved = customerRepository.save(customer);
        auditLogService.log(userId, shopId, saved.getId(), "CUSTOMER", "CREATED",
                String.format("Tạo khách hàng: %s (%s)", saved.getName(), saved.getPhone()));
        return toResponse(saved);
    }

    public CustomerResponse updateCustomer(String shopId, String id, CustomerRequest request) {
        Customer existing = customerRepository.findByIdAndDeletedFalse(id)
                .filter(c -> c.getShopId().equals(shopId))
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.CUSTOMER_NOT_FOUND));

        if (!existing.getBranchId().equals(request.getBranchId())) {
            throw new BusinessException(ApiCode.UNAUTHORIZED);
        }

        existing.setName(request.getName());
        existing.setPhone(request.getPhone());
        existing.setEmail(request.getEmail());
        existing.setAddress(request.getAddress());
        existing.setNote(request.getNote());

        Customer saved = customerRepository.save(existing);
        auditLogService.log(null, shopId, saved.getId(), "CUSTOMER", "UPDATED",
                String.format("Cập nhật khách hàng: %s (%s)", saved.getName(), saved.getPhone()));
        return toResponse(saved);
    }

    public void deleteCustomer(String shopId, String branchId, String id) {
        Customer customer = customerRepository.findByIdAndDeletedFalse(id)
                .filter(c -> c.getShopId().equals(shopId))
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.CUSTOMER_NOT_FOUND));

        if (!customer.getBranchId().equals(branchId)) {
            throw new BusinessException(ApiCode.UNAUTHORIZED);
        }

        customer.setDeleted(true);
        customerRepository.save(customer);
        auditLogService.log(null, shopId, customer.getId(), "CUSTOMER", "DELETED",
                String.format("Xoá mềm khách hàng: %s (%s)", customer.getName(), customer.getPhone()));
    }

    private CustomerResponse toResponse(Customer c) {
        return CustomerResponse.builder()
                .id(c.getId())
                .name(c.getName())
                .phone(c.getPhone())
                .email(c.getEmail())
                .address(c.getAddress())
                .note(c.getNote())
                .build();
    }
}

// File: src/main/java/com/example/sales/service/ExcelExportService.java
package com.example.sales.service;

import com.example.sales.dto.product.ProductResponse; // Import ProductResponse
import com.example.sales.export.GenericExcelExporter;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import java.io.ByteArrayOutputStream; // Thêm import này
import java.io.IOException;
import java.util.List;
import java.util.function.Function;
@Service
@RequiredArgsConstructor
public class ExcelExportService {
    // Chúng ta sẽ không cần ProductRepository trực tiếp ở đây nữa,
    // mà sẽ sử dụng ProductService để lấy dữ liệu đã được map sang ProductResponse
    private final ProductService productService; // Tiêm ProductService

    // Phương thức exportExcel tổng quát có thể giữ nguyên nếu bạn vẫn dùng nó ở nơi khác
    public <T> ResponseEntity<byte[]> exportExcel(String fileName,
                                                  String sheetName,
                                                  List<String> headers,
                                                  List<T> data,
                                                  Function<T, List<String>> rowMapper) {
        try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) { // Sử dụng ByteArrayOutputStream
            GenericExcelExporter<T> exporter = new GenericExcelExporter<>();
            exporter.export(sheetName, headers, data, rowMapper, bos); // Ghi vào OutputStream

            byte[] content = bos.toByteArray(); // Lấy byte array từ OutputStream

            HttpHeaders responseHeaders = new HttpHeaders();
            responseHeaders.setContentType(MediaType.APPLICATION_OCTET_STREAM);
            responseHeaders.setContentDisposition(ContentDisposition.attachment().filename(fileName).build());

            return new ResponseEntity<>(content, responseHeaders, HttpStatus.OK);
        } catch (Exception e) {
            throw new RuntimeException("Không thể export file Excel", e);
        }
    }

    // ✅ Phương thức exportProducts được cập nhật để sử dụng ProductService và ProductResponse
    public ResponseEntity<byte[]> exportProducts(String shopId, String branchId) throws IOException {
        // Lấy dữ liệu ProductResponse từ ProductService
        // Sử dụng phân trang để tránh load quá nhiều dữ liệu cùng lúc
        Pageable pageable = PageRequest.of(0, 1000); // Lấy 1000 sản phẩm mỗi lần
        Page<ProductResponse> productPage;
        List<ProductResponse> allProducts = new java.util.ArrayList<>();

        do {
            productPage = productService.getAllByShop(shopId, branchId, pageable);
            allProducts.addAll(productPage.getContent());
            if (productPage.hasNext()) {
                pageable = productPage.nextPageable();
            } else {
                break;
            }
        } while (true);


        // Định nghĩa headers cho file Excel
        List<String> headers = List.of(
                "SKU", "Tên sản phẩm", "Danh mục", "Chi nhánh ID",
                "Số lượng", "Giá", "Đơn vị", "URL Hình ảnh", "Mô tả", "Trạng thái hoạt động"
        );

        // Định nghĩa cách map ProductResponse thành các dòng dữ liệu
        Function<ProductResponse, List<String>> rowMapper = p -> List.of(
                p.getSku(),
                p.getName(),
                p.getCategory(),
                p.getBranchId(),
                String.valueOf(p.getQuantity()),
                String.valueOf(p.getPrice()),
                p.getUnit(),
                p.getImageUrl() != null ? p.getImageUrl() : "",
                p.getDescription() != null ? p.getDescription() : "",
                p.isActiveInBranch() ? "Có" : "Không"
        );

        // Sử dụng GenericExcelExporter để tạo file Excel
        try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) {
            GenericExcelExporter<ProductResponse> exporter = new GenericExcelExporter<>();
            exporter.export("Products", headers, allProducts, rowMapper, bos);
            byte[] content = bos.toByteArray();

            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, ContentDisposition.attachment().filename("products.xlsx").build().toString())
                    .contentType(MediaType.APPLICATION_OCTET_STREAM)
                    .body(content);
        } catch (Exception e) {
            throw new RuntimeException("Không thể export file Excel sản phẩm", e);
        }
    }
}

// File: src/main/java/com/example/sales/service/FileUploadService.java
package com.example.sales.service;

import com.example.sales.constant.ApiCode;
import com.example.sales.exception.BusinessException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class FileUploadService {

    @Value("${app.upload.temp-dir:uploads/temp/}")
    private String tempDir;

    private static final long MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
    private static final List<String> ALLOWED_MIME_TYPES = List.of(
            "image/jpeg",
            "image/png",
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    );

    public String upload(MultipartFile file) {
        try {
            log.info("Bắt đầu upload file: tên gốc = {}", file.getOriginalFilename());

            if (file.isEmpty()) {
                throw new BusinessException(ApiCode.VALIDATION_ERROR);
            }

            if (file.getSize() > MAX_FILE_SIZE) {
                throw new BusinessException(ApiCode.VALIDATION_FILE_ERROR);
            }

            String contentType = file.getContentType();
            if (!ALLOWED_MIME_TYPES.contains(contentType)) {
                throw new BusinessException(ApiCode.VALIDATION_FILE_ERROR);
            }

            // Tạo tên file ngẫu nhiên
            String filename = UUID.randomUUID() + "_" + sanitize(file.getOriginalFilename());

            // Đường dẫn thư mục uploads/temp/
            Path uploadPath = Path.of(tempDir).toAbsolutePath();
            Files.createDirectories(uploadPath);
            log.debug("Thư mục upload: {}", uploadPath);

            // Ghi file vào disk
            Path filePath = uploadPath.resolve(filename);
            file.transferTo(filePath);
            log.info("File đã được lưu tại: {}", filePath);

            // Trả về URL public
            return "/uploads/temp/" + filename;

        } catch (BusinessException e) {
            throw e;
        } catch (Exception e) {
            log.error("Lỗi khi upload file", e);
            throw new RuntimeException("Không thể upload file", e);
        }
    }

    // Dọn tên file cho an toàn
    private String sanitize(String original) {
        String sanitized = original.replaceAll("[^a-zA-Z0-9._-]", "_");
        log.debug("Sanitize tên file: {} -> {}", original, sanitized);
        return sanitized;
    }

    public String moveToProduct(String imageUrl) {
        try {
            log.info("Di chuyển file từ temp sang product: {}", imageUrl);

            // Chỉ xử lý nếu là ảnh trong uploads/temp
            if (imageUrl == null || !imageUrl.startsWith("/uploads/temp/")) {
                log.warn("Bỏ qua file không thuộc temp: {}", imageUrl);
                return imageUrl; // đã là ảnh final hoặc ảnh CDN thì bỏ qua
            }

            String filename = Path.of(imageUrl).getFileName().toString();

            Path tempPath = Path.of(tempDir).resolve(filename).toAbsolutePath();
            Path productDir = Path.of("uploads/product").toAbsolutePath();
            Files.createDirectories(productDir);
            Path targetPath = productDir.resolve(filename);

            if (Files.exists(tempPath)) {
                Files.move(tempPath, targetPath);
                log.info("Đã chuyển file: {} -> {}", tempPath, targetPath);
            } else {
                log.warn("File không tồn tại tại tempPath: {}", tempPath);
            }

            return "/uploads/product/" + filename;

        } catch (Exception e) {
            log.error("Lỗi khi di chuyển ảnh từ temp sang product", e);
            throw new RuntimeException("Không thể chuyển ảnh từ temp sang product", e);
        }
    }

}

// File: src/main/java/com/example/sales/service/InventoryService.java
package com.example.sales.service;

import com.example.sales.dto.inventory.InventoryTransactionResponse;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

public interface InventoryService {

    /**
     * Nhập thêm số lượng sản phẩm vào kho của chi nhánh.
     * Tạo một InventoryTransaction loại IMPORT.
     *
     * @param userId ID của người dùng thực hiện.
     * @param shopId ID của cửa hàng.
     * @param branchProductId ID của BranchProduct cần nhập.
     * @param quantity Số lượng nhập thêm.
     * @param note Ghi chú cho giao dịch.
     * @return Số lượng tồn kho mới của sản phẩm tại chi nhánh.
     */
    int importProductQuantity(String userId, String shopId, String branchId, String branchProductId, int quantity, String note);

    /**
     * Xuất bớt số lượng sản phẩm khỏi kho của chi nhánh.
     * Tạo một InventoryTransaction loại EXPORT.
     * Kiểm tra số lượng tồn kho trước khi xuất.
     *
     * @param userId ID của người dùng thực hiện.
     * @param shopId ID của cửa hàng.
     * @param branchProductId ID của BranchProduct cần xuất.
     * @param quantity Số lượng xuất đi.
     * @param note Ghi chú cho giao dịch.
     * @param referenceId ID tham chiếu (ví dụ: ID đơn hàng).
     * @return Số lượng tồn kho mới của sản phẩm tại chi nhánh.
     */
    int exportProductQuantity(String userId, String shopId, String branchId, String branchProductId, int quantity, String note, String referenceId);

    /**
     * Điều chỉnh số lượng tồn kho của sản phẩm tại chi nhánh.
     * Có thể tăng hoặc giảm số lượng, tạo một InventoryTransaction loại ADJUSTMENT.
     *
     * @param userId ID của người dùng thực hiện.
     * @param shopId ID của cửa hàng.
     * @param branchProductId ID của BranchProduct cần điều chỉnh.
     * @param newQuantity Số lượng tồn kho mong muốn sau điều chỉnh.
     * @param note Ghi chú cho giao dịch.
     * @return Số lượng tồn kho mới của sản phẩm tại chi nhánh.
     */
    int adjustProductQuantity(String userId, String shopId, String branchId, String branchProductId, int newQuantity, String note);

    /**
     * Lấy lịch sử giao dịch tồn kho cho một sản phẩm cụ thể.
     *
     * @param productId ID của BranchProduct (sản phẩm chi nhánh).
     * @param pageable Thông tin phân trang.
     * @return Trang chứa danh sách các giao dịch tồn kho.
     */
    Page<InventoryTransactionResponse> getTransactionHistory(String userId, String shopId, String branchId, String branchProductId, Pageable pageable);

    /**
     * Kiểm tra xem cửa hàng có yêu cầu quản lý tồn kho hay không.
     *
     * @param shopId ID của cửa hàng.
     * @return true nếu cửa hàng yêu cầu quản lý tồn kho, ngược lại false.
     */
    boolean isInventoryManagementRequired(String shopId);
}

// File: src/main/java/com/example/sales/service/MailService.java
package com.example.sales.service;

import jakarta.mail.MessagingException;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;

import jakarta.mail.internet.MimeMessage;
import org.thymeleaf.TemplateEngine;
import org.thymeleaf.context.Context;

import java.util.Map;

@Service
@RequiredArgsConstructor
public class MailService {

    private final JavaMailSender mailSender;
    private final TemplateEngine templateEngine;

    @Value("${spring.mail.username}")
    private String from;

    public void send(String to, String subject, String htmlContent) {
        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, "utf-8");

            helper.setText(htmlContent, true); // true = html
            helper.setTo(to);
            helper.setSubject(subject);
            helper.setFrom(from);

            mailSender.send(message);
        } catch (MessagingException e) {
            throw new RuntimeException("Không gửi được email", e);
        }
    }

    public void sendHtmlTemplate(String to, String subject, String templateName, Map<String, Object> model) {
        try {
            Context context = new Context();
            context.setVariables(model);

            String htmlContent = templateEngine.process(templateName, context);

            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, "utf-8");

            helper.setTo(to);
            helper.setSubject(subject);
            helper.setFrom(from);
            helper.setText(htmlContent, true);

            mailSender.send(message);
        } catch (MessagingException e) {
            throw new RuntimeException("Không gửi được email", e);
        }
    }
}

// File: src/main/java/com/example/sales/service/OrderService.java
package com.example.sales.service;

import com.example.sales.cache.OrderCache;
import com.example.sales.constant.ApiCode;
import com.example.sales.constant.DiscountType;
import com.example.sales.constant.OrderStatus;
import com.example.sales.constant.TableStatus;
import com.example.sales.dto.order.OrderItemResponse;
import com.example.sales.dto.order.OrderRequest;
import com.example.sales.dto.order.OrderResponse;
import com.example.sales.dto.order.OrderUpdateRequest;
import com.example.sales.exception.BusinessException;
import com.example.sales.exception.ResourceNotFoundException;
import com.example.sales.model.*;
import com.example.sales.repository.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j // Khởi tạo Log
public class OrderService extends BaseService {

    private final OrderRepository orderRepository;
    private final TableRepository tableRepository;
    private final ProductRepository productRepository;
    private final BranchProductRepository branchProductRepository;
    private final PromotionRepository promotionRepository;
    private final AuditLogService auditLogService;
    private final ShopRepository shopRepository;
    private final InventoryService inventoryService;
    private final OrderCache orderCache;

    @Transactional
    public OrderResponse createOrder(String userId, String branchId, String shopId, OrderRequest request) {
        Order order = new Order();
        order.setShopId(shopId);
        order.setTableId(request.getTableId());
        order.setUserId(userId);
        order.setNote(request.getNote());
        order.setStatus(OrderStatus.PENDING);
        order.setPaid(false);

        if (branchId == null || branchId.isBlank()) {
            log.error("Branch ID không được để trống");
            throw new BusinessException(ApiCode.VALIDATION_ERROR);
        }
        order.setBranchId(branchId);

        double[] totals = {0, 0};

        // Lấy thông tin shop để kiểm tra loại hình kinh doanh (có quản lý tồn kho không)
        Shop shop = shopRepository.findByIdAndDeletedFalse(shopId)
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.SHOP_NOT_FOUND));


        List<OrderItem> orderItems = request.getItems().stream().map(reqItem -> {
            // Lấy Product master
            Product masterProduct = productRepository.findByIdAndDeletedFalse(reqItem.getProductId())
                    .filter(p -> p.getShopId().equals(shopId))
                    .orElseThrow(() -> new ResourceNotFoundException(ApiCode.PRODUCT_NOT_FOUND));

            // Lấy BranchProduct cho chi nhánh và sản phẩm cụ thể
            BranchProduct branchProduct = branchProductRepository
                    .findByProductIdAndBranchIdAndDeletedFalse(masterProduct.getId(), branchId)
                    .orElseThrow(() -> new ResourceNotFoundException(ApiCode.PRODUCT_NOT_FOUND));


            double basePrice = branchProduct.getPrice();
            double finalPrice = basePrice;
            String promoId = null;

            Promotion promo = findApplicablePromotion(shopId, branchId, masterProduct.getId()); // Áp dụng promo dựa trên masterProduct ID
            if (promo != null) {
                promoId = promo.getId();
                if (promo.getDiscountType() == DiscountType.PERCENT) {
                    finalPrice = basePrice * (1 - promo.getDiscountValue() / 100.0);
                } else if (promo.getDiscountType() == DiscountType.AMOUNT) {
                    finalPrice = Math.max(0, basePrice - promo.getDiscountValue());
                }
            }

            OrderItem item = OrderItem.builder()
                    .productId(masterProduct.getId()) // Lưu master product ID
                    .branchProductId(branchProduct.getId()) // Lưu BranchProduct ID
                    .productName(masterProduct.getName())
                    .quantity(reqItem.getQuantity())
                    .price(basePrice)
                    .priceAfterDiscount(finalPrice)
                    .appliedPromotionId(promoId)
                    .build();

            totals[0] += reqItem.getQuantity();
            totals[1] += reqItem.getQuantity() * finalPrice;

            return item;
        }).toList();

        order.setItems(orderItems);
        order.setTotalAmount(totals[0]);
        order.setTotalPrice(totals[1]);

        Order created = orderRepository.save(order);

        // Điều chỉnh tồn kho sau khi tạo đơn hàng
        if (shop.getType().isTrackInventory()) {
            for (OrderItem item : created.getItems()) {
                // Sử dụng BranchProduct ID để điều chỉnh tồn kho
                inventoryService.exportProductQuantity(
                        userId, shopId, created.getBranchId(), item.getBranchProductId(),
                        item.getQuantity(), "Xuất kho theo đơn hàng " + created.getId(), created.getId());
            }
        }
        occupyTable(created);
        auditLogService.log(userId, shopId, created.getId(), "ORDER", "CREATED", "Tạo đơn hàng mới");
        return toResponse(created);
    }

    public void cancelOrder(String userId, String shopId, String orderId) {
        Order order = orderCache.getOrderByShop(orderId, shopId);

        if (order.isPaid()) {
            throw new BusinessException(ApiCode.ORDER_ALREADY_PAID);
        }

        order.setStatus(OrderStatus.CANCELLED);
        orderRepository.save(order);

        // Hoàn kho khi hủy đơn hàng nếu shop có quản lý tồn kho
        Shop shop = shopRepository.findByIdAndDeletedFalse(shopId)
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.SHOP_NOT_FOUND));
        if (shop.getType().isTrackInventory()) {
            for (OrderItem item : order.getItems()) {
                inventoryService.importProductQuantity(
                        userId, shopId, order.getBranchId(), item.getBranchProductId(),
                        item.getQuantity(), "Hoàn kho khi hủy đơn hàng " + orderId);
            }
        }

        auditLogService.log(userId, shopId, order.getId(), "ORDER", "CANCELLED", "Huỷ đơn hàng");
    }

    public OrderResponse confirmPayment(String userId, String shopId, String orderId, String paymentId, String paymentMethod) {
        Order order = orderCache.getOrderByShop(orderId, shopId);

        if (order.isPaid()) {
            throw new BusinessException(ApiCode.ORDER_ALREADY_PAID);
        }

        order.setPaid(true);
        order.setPaymentId(paymentId);
        order.setPaymentMethod(paymentMethod);
        order.setPaymentTime(LocalDateTime.now());
        order.setStatus(OrderStatus.COMPLETED);

        Order updated = orderRepository.save(order);
        releaseTable(updated); // Giải phóng bàn khi đơn hàng hoàn thành/thanh toán
        auditLogService.log(userId, shopId, order.getId(), "ORDER", "PAYMENT_CONFIRMED",
                "Xác nhận thanh toán đơn hàng với ID: %s".formatted(orderId));
        return toResponse(updated);
    }

    public OrderResponse updateStatus(String userId, String shopId, String orderId, OrderStatus newStatus) {
        Order order = orderCache.getOrderByShop(orderId, shopId);

        if (order.getStatus() == OrderStatus.CANCELLED || order.getStatus() == OrderStatus.COMPLETED) {
            log.error("Không thể cập nhật trạng thái đơn hàng đã hủy hoặc đã hoàn thành");
            throw new BusinessException(ApiCode.VALIDATION_ERROR);
        }
        if (newStatus == OrderStatus.CANCELLED && order.isPaid()) {
            log.error("Không thể hủy đơn hàng đã thanh toán");
            throw new BusinessException(ApiCode.ORDER_ALREADY_PAID);
        }


        OrderStatus oldStatus = order.getStatus();
        order.setStatus(newStatus);

        if (newStatus == OrderStatus.COMPLETED && !order.isPaid()) {
            // Nếu đơn hàng chuyển sang COMPLETED mà chưa thanh toán, coi như thanh toán bằng tiền mặt
            order.setPaid(true);
            order.setPaymentTime(LocalDateTime.now());
            order.setPaymentMethod("Cash");
            releaseTable(order); // Giải phóng bàn
        }

        Order updated = orderRepository.save(order);
        if (!oldStatus.equals(newStatus)) {
            auditLogService.log(userId, shopId, order.getId(), "ORDER", "STATUS_UPDATED",
                    "Cập nhật trạng thái từ %s → %s".formatted(oldStatus, newStatus));
        }

        return toResponse(updated);
    }

    private void occupyTable(Order order) {
        if (order.getTableId() != null && !order.getTableId().isBlank()) { // Kiểm tra null và blank
            tableRepository.findByIdAndDeletedFalse(order.getTableId()).ifPresent(table -> { // Tìm bàn không bị xóa
                table.setStatus(TableStatus.OCCUPIED);
                table.setCurrentOrderId(order.getId());
                tableRepository.save(table);
            });
        }
    }

    private void releaseTable(Order order) {
        if (order.getTableId() != null && !order.getTableId().isBlank()) {
            tableRepository.findByIdAndDeletedFalse(order.getTableId()).ifPresent(table -> {
                table.setStatus(TableStatus.AVAILABLE);
                table.setCurrentOrderId(null);
                tableRepository.save(table);
            });
        }
    }

    private Promotion findApplicablePromotion(String shopId, String branchId, String productId) {
        LocalDateTime now = LocalDateTime.now();
        return promotionRepository.findByShopIdAndDeletedFalse(shopId).stream()
                .filter(Promotion::isActive)
                .filter(p -> p.getBranchId() == null || p.getBranchId().equals(branchId)) // Khuyến mãi có thể áp dụng cho toàn bộ shop (branchId = null) hoặc riêng cho 1 branch
                .filter(p -> !p.getStartDate().isAfter(now) && !p.getEndDate().isBefore(now))
                .filter(p -> p.getApplicableProductIds() == null
                        || p.getApplicableProductIds().isEmpty()
                        || p.getApplicableProductIds().contains(productId)) // Áp dụng cho masterProduct ID
                .findFirst()
                .orElse(null);
    }

    public Page<OrderResponse> getShopOrders(String shopId, Pageable pageable) {
        return orderRepository.findByShopIdOrderByCreatedAtDesc(shopId, pageable)
                .map(this::toResponse);
    }

    public Page<OrderResponse> getOrdersByStatus(String shopId, OrderStatus status, String branchId, Pageable pageable) {
        return orderRepository.findByShopIdAndBranchIdAndStatusAndDeletedFalse(shopId, branchId, status, pageable)
                .map(this::toResponse);
    }

    @Transactional
    public OrderResponse updateOrder(String userId, String shopId, String orderId, OrderUpdateRequest request) {
        Order order = orderCache.getOrderByShop(orderId, shopId);

        if (order.isPaid()) {
            throw new BusinessException(ApiCode.ORDER_ALREADY_PAID);
        }

        // Gỡ bàn cũ nếu đổi bàn
        if (request.getTableId() != null && !request.getTableId().equals(order.getTableId())) {
            releaseTable(order);
            String oldTableId = order.getTableId();
            order.setTableId(request.getTableId());
            occupyTable(order);
            auditLogService.log(userId, shopId, orderId, "ORDER", "TABLE_CHANGED",
                    "Đổi bàn cho đơn hàng từ %s sang %s".formatted(oldTableId, request.getTableId()));
        }

        if (request.getNote() != null) {
            order.setNote(request.getNote());
        }

        if (request.getItems() != null && !request.getItems().isEmpty()) {
            Shop shop = shopRepository.findByIdAndDeletedFalse(shopId)
                    .orElseThrow(() -> new ResourceNotFoundException(ApiCode.SHOP_NOT_FOUND));

            // 🔁 1. Hoàn tác lại tồn kho theo đơn hàng cũ (nếu shop có quản lý tồn kho)
            if (shop.getType().isTrackInventory()) {
                for (OrderItem oldItem : order.getItems()) {
                    inventoryService.importProductQuantity(
                            userId, shopId, order.getBranchId(), oldItem.getBranchProductId(), // Sử dụng BranchProduct ID
                            oldItem.getQuantity(), "Hoàn kho khi cập nhật đơn hàng " + orderId);
                }
            }

            // 🔁 2. Áp dụng lại tồn kho cho danh sách mới và tính toán lại tổng tiền
            double[] totals = {0, 0};

            List<OrderItem> updatedItems = request.getItems().stream().map(reqItem -> {
                // Lấy Product master
                Product masterProduct = productRepository.findByIdAndDeletedFalse(reqItem.getProductId())
                        .filter(p -> p.getShopId().equals(shopId))
                        .orElseThrow(() -> new ResourceNotFoundException(ApiCode.PRODUCT_NOT_FOUND));

                // Lấy BranchProduct cho chi nhánh và sản phẩm cụ thể
                BranchProduct branchProduct = branchProductRepository
                        .findByProductIdAndBranchIdAndDeletedFalse(masterProduct.getId(), order.getBranchId()) // Lấy branchId từ order
                        .orElseThrow(() -> new ResourceNotFoundException(ApiCode.PRODUCT_NOT_FOUND));

                double basePrice = branchProduct.getPrice();
                double finalPrice = basePrice;
                String promoId = null;

                Promotion promo = findApplicablePromotion(shopId, order.getBranchId(), masterProduct.getId());
                if (promo != null) {
                    promoId = promo.getId();
                    if (promo.getDiscountType() == DiscountType.PERCENT) {
                        finalPrice = basePrice * (1 - promo.getDiscountValue() / 100.0);
                    } else if (promo.getDiscountType() == DiscountType.AMOUNT) {
                        finalPrice = Math.max(0, basePrice - promo.getDiscountValue());
                    }
                }

                OrderItem item = OrderItem.builder()
                        .productId(masterProduct.getId())
                        .branchProductId(branchProduct.getId()) // Lưu BranchProduct ID
                        .productName(masterProduct.getName())
                        .quantity(reqItem.getQuantity())
                        .price(basePrice)
                        .priceAfterDiscount(finalPrice)
                        .appliedPromotionId(promoId)
                        .build();

                // Trừ kho mới (nếu shop có quản lý tồn kho)
                if (shop.getType().isTrackInventory()) {
                    inventoryService.exportProductQuantity(
                            userId, shopId, order.getBranchId(), item.getBranchProductId(), // Sử dụng BranchProduct ID
                            item.getQuantity(), "Xuất kho khi cập nhật đơn hàng " + orderId, orderId);
                }

                totals[0] += reqItem.getQuantity();
                totals[1] += reqItem.getQuantity() * finalPrice;
                return item;
            }).toList();

            order.setItems(updatedItems);
            order.setTotalAmount(totals[0]);
            order.setTotalPrice(totals[1]);
        }

        Order updated = orderRepository.save(order);
        auditLogService.log(userId, shopId, orderId, "ORDER", "UPDATED", "Cập nhật đơn hàng");
        return toResponse(updated);
    }

    private OrderResponse toResponse(Order order) {
        return OrderResponse.builder()
                .id(order.getId())
                .tableId(order.getTableId())
                .branchId(order.getBranchId()) // Thêm branchId vào response
                .note(order.getNote())
                .status(order.getStatus())
                .paid(order.isPaid())
                .paymentMethod(order.getPaymentMethod())
                .paymentId(order.getPaymentId())
                .paymentTime(order.getPaymentTime())
                .totalAmount(order.getTotalAmount())
                .totalPrice(order.getTotalPrice())
                .items(order.getItems().stream().map(this::toItemResponse).toList())
                .build();
    }

    private OrderItemResponse toItemResponse(OrderItem item) {
        return OrderItemResponse.builder()
                .productId(item.getProductId())
                .branchProductId(item.getBranchProductId()) // Thêm branchProductId vào response
                .productName(item.getProductName())
                .quantity(item.getQuantity())
                .price(item.getPrice())
                .priceAfterDiscount(item.getPriceAfterDiscount())
                .appliedPromotionId(item.getAppliedPromotionId())
                .build();
    }
}

// File: src/main/java/com/example/sales/service/PaymentService.java
package com.example.sales.service;

import com.example.sales.constant.SubscriptionActionType;
import com.example.sales.constant.SubscriptionPlan;
import com.example.sales.model.Shop;
import com.example.sales.model.SubscriptionHistory;
import com.example.sales.model.User;
import com.example.sales.repository.SubscriptionHistoryRepository;
import com.example.sales.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.Map;

@Service
@RequiredArgsConstructor
public class PaymentService {

    private final SubscriptionHistoryRepository historyRepository;
    private final UserRepository userRepository; // Giả sử bạn có repository để lấy thông tin người dùng
    private final MailService mailService; // Giả sử bạn có service gửi email

    public void upgradeShopPlan(Shop shop, SubscriptionPlan newPlan, int months) {
        SubscriptionPlan oldPlan = shop.getPlan();

        shop.setPlan(newPlan);
        shop.setPlanExpiry(LocalDateTime.now().plusMonths(months));

        // Lưu lịch sử nâng cấp
        SubscriptionHistory history = SubscriptionHistory.builder()
                .shopId(shop.getId())
                .userId(shop.getOwnerId())
                .oldPlan(oldPlan)
                .newPlan(newPlan)
                .durationMonths(months)
                .paymentMethod("MANUAL") // hoặc "WEBHOOK", "STRIPE", "VNPAY", ...
                .transactionId(null) // có thể set từ webhook
                .actionType(SubscriptionActionType.UPGRADE)
                .build();

        historyRepository.save(history);

        // Gửi mail thông báo nâng cấp
        User owner = userRepository.findById(shop.getOwnerId()).orElse(null);
        if (owner != null && owner.getEmail() != null) {
            Map<String, Object> model = Map.of(
                    "fullName", owner.getFullName(),
                    "newPlan", newPlan.name(),
                    "shopName", shop.getName(),
                    "duration", months + " tháng"
            );

            mailService.sendHtmlTemplate(
                    owner.getEmail(),
                    "🎉 Gói " + newPlan.name() + " đã được kích hoạt",
                    "emails/plan-upgraded",
                    model
            );
        }
    }
}

// File: src/main/java/com/example/sales/service/ProductService.java
package com.example.sales.service;

import com.example.sales.dto.product.ProductRequest;
import com.example.sales.dto.product.ProductResponse;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;

public interface ProductService {
    ProductResponse createProduct(String shopId, String branchId, ProductRequest request);

    // id ở đây là id của BranchProduct
    ProductResponse updateProduct(String userId, String shopId, String branchId, String id, ProductRequest request);

    // id ở đây là id của BranchProduct
    void deleteProduct(String userId, String shopId, String branchId, String id);

    // id ở đây là id của BranchProduct
    ProductResponse getProduct(String shopId, String branchId, String id);

    // productId ở đây là id của BranchProduct để toggle activeInBranch
    ProductResponse toggleActive(String userId, String shopId, String branchId, String branchProductId);

    List<ProductResponse> getLowStockProducts(String shopId, String branchId, int threshold);

    Page<ProductResponse> searchProducts(String shopId, String branchId, String keyword, Pageable pageable);
}

// File: src/main/java/com/example/sales/service/PromotionService.java
package com.example.sales.service;

import com.example.sales.constant.ApiCode;
import com.example.sales.dto.promotion.PromotionRequest;
import com.example.sales.dto.promotion.PromotionResponse;
import com.example.sales.exception.BusinessException;
import com.example.sales.exception.ResourceNotFoundException;
import com.example.sales.model.Promotion;
import com.example.sales.repository.PromotionRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class PromotionService {

    private final PromotionRepository promotionRepository;
    private final AuditLogService auditLogService;

    public Page<PromotionResponse> getAll(String userId, String shopId, String branchId, Pageable pageable) {
        return promotionRepository.findByShopIdAndBranchIdAndDeletedFalse(shopId, branchId, pageable)
                .map(this::toResponse);
    }

    public PromotionResponse create(String userId, String shopId, PromotionRequest request) {
        Promotion promotion = Promotion.builder()
                .shopId(shopId)
                .name(request.getName())
                .discountType(request.getDiscountType())
                .discountValue(request.getDiscountValue())
                .applicableProductIds(request.getApplicableProductIds())
                .startDate(request.getStartDate())
                .endDate(request.getEndDate())
                .active(request.isActive())
                .branchId(request.getBranchId())
                .build();

        Promotion saved = promotionRepository.save(promotion);
        auditLogService.log(userId, shopId, saved.getId(), "PROMOTION", "CREATED",
                String.format("Tạo khuyến mãi: %s (%.2f %s)",
                        saved.getName(),
                        saved.getDiscountValue(),
                        saved.getDiscountType()));
        return toResponse(saved);
    }

    public PromotionResponse update(String userId, String shopId, String id, PromotionRequest request) {
        Promotion promotion = promotionRepository.findByIdAndDeletedFalse(id)
                .filter(p -> p.getShopId().equals(shopId))
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.PROMOTION_NOT_FOUND));

        if (!promotion.getBranchId().equals(request.getBranchId())) {
            throw new BusinessException(ApiCode.UNAUTHORIZED);
        }

        promotion.setName(request.getName());
        promotion.setDiscountType(request.getDiscountType());
        promotion.setDiscountValue(request.getDiscountValue());
        promotion.setApplicableProductIds(request.getApplicableProductIds());
        promotion.setStartDate(request.getStartDate());
        promotion.setEndDate(request.getEndDate());
        promotion.setActive(request.isActive());

        Promotion saved = promotionRepository.save(promotion);
        auditLogService.log(userId, shopId, saved.getId(), "PROMOTION", "UPDATED",
                String.format("Cập nhật khuyến mãi: %s", saved.getName()));
        return toResponse(saved);
    }

    public void delete(String userId, String shopId, String id) {
        Promotion promotion = promotionRepository.findByIdAndDeletedFalse(id)
                .filter(p -> p.getShopId().equals(shopId))
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.PROMOTION_NOT_FOUND));

        promotion.setDeleted(true);
        promotionRepository.save(promotion);
        auditLogService.log(userId, shopId, promotion.getId(), "PROMOTION", "DELETED",
                String.format("Xoá mềm khuyến mãi: %s", promotion.getName()));

    }

    private PromotionResponse toResponse(Promotion p) {
        return PromotionResponse.builder()
                .id(p.getId())
                .name(p.getName())
                .discountType(p.getDiscountType())
                .discountValue(p.getDiscountValue())
                .applicableProductIds(p.getApplicableProductIds())
                .startDate(p.getStartDate())
                .endDate(p.getEndDate())
                .active(p.isActive())
                .build();
    }
}

// File: src/main/java/com/example/sales/service/ReportService.java
package com.example.sales.service;

import com.example.sales.dto.report.DailyReportResponse;
import com.example.sales.dto.report.ReportRequest;
import com.example.sales.dto.report.ReportResponse;
import com.example.sales.model.Order;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.aggregation.Aggregation;
import org.springframework.data.mongodb.core.aggregation.AggregationResults;
import org.springframework.data.mongodb.core.aggregation.MatchOperation;
import org.springframework.data.mongodb.core.aggregation.ProjectionOperation;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

import static org.springframework.data.mongodb.core.aggregation.Aggregation.*;

@Service
@RequiredArgsConstructor
public class ReportService {

    private final MongoTemplate mongoTemplate;
    private final ExcelExportService excelExportService;

    public ReportResponse getReport(String shopId, ReportRequest request) {
        MatchOperation match = buildMatchOperation(shopId, request);

        Aggregation aggregation = newAggregation(
                match,
                unwind("items"),
                group()
                        .count().as("totalOrders")
                        .sum("items.quantity").as("totalProductsSold")
                        .sum("totalPrice").as("totalRevenue")
        );

        AggregationResults<ReportResponse> results =
                mongoTemplate.aggregate(aggregation, Order.class, ReportResponse.class);

        ReportResponse response = results.getUniqueMappedResult();

        return response != null ? response : ReportResponse.builder()
                .totalOrders(0)
                .totalProductsSold(0)
                .totalRevenue(0)
                .build();
    }

    public List<DailyReportResponse> getDailyReport(String shopId, ReportRequest request) {
        MatchOperation match = buildMatchOperation(shopId, request);

        ProjectionOperation projectDate = project()
                .andExpression("year(createdAt)").as("year")
                .andExpression("month(createdAt)").as("month")
                .andExpression("dayOfMonth(createdAt)").as("day")
                .and("totalPrice").as("totalPrice")
                .and("items").as("items");

        Aggregation aggregation = newAggregation(
                match,
                projectDate,
                unwind("items"),
                group("year", "month", "day")
                        .count().as("totalOrders")
                        .sum("items.quantity").as("totalProductsSold")
                        .sum("totalPrice").as("totalRevenue"),
                project()
                        .andExpression("dateFromParts(year: _id.year, month: _id.month, day: _id.day)").as("date")
                        .andInclude("totalOrders", "totalProductsSold", "totalRevenue"),
                sort(Sort.Direction.ASC, "date")
        );

        AggregationResults<DailyReportResponse> results =
                mongoTemplate.aggregate(aggregation, Order.class, DailyReportResponse.class);

        return results.getMappedResults();
    }

    public ResponseEntity<byte[]> exportDailyReportExcel(String shopId,
                                                         @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
                                                         @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {

        ReportRequest request = new ReportRequest();
        request.setStartDate(startDate);
        request.setEndDate(endDate);

        List<DailyReportResponse> data = getDailyReport(shopId, request);

        DateTimeFormatter df = DateTimeFormatter.ofPattern("dd/MM/yyyy");

        return excelExportService.exportExcel(
                "daily-report.xlsx",
                "Báo cáo theo ngày",
                List.of("Ngày", "Tổng đơn", "Tổng sản phẩm", "Tổng doanh thu"),
                data,
                r -> List.of(
                        r.getDate().format(df),
                        String.valueOf(r.getTotalOrders()),
                        String.valueOf(r.getTotalProductsSold()),
                        String.valueOf(r.getTotalRevenue())
                )
        );
    }

    private MatchOperation buildMatchOperation(String shopId, ReportRequest request) {
        Criteria criteria = Criteria.where("shopId").is(shopId);

        if (request.getStatus() != null) {
            criteria = criteria.and("status").is(request.getStatus());
        }

        if (request.getStartDate() != null && request.getEndDate() != null) {
            LocalDateTime start = request.getStartDate().atStartOfDay();
            LocalDateTime end = request.getEndDate().atTime(LocalTime.MAX);
            criteria = criteria.and("createdAt").gte(start).lte(end);
        }

        return match(criteria);
    }
}

// File: src/main/java/com/example/sales/service/ShopService.java
package com.example.sales.service;

import com.example.sales.cache.ShopCache;
import com.example.sales.constant.ApiCode;
import com.example.sales.constant.ShopRole;
import com.example.sales.constant.UserRole;
import com.example.sales.dto.shop.ShopAdminResponse;
import com.example.sales.dto.shop.ShopRequest;
import com.example.sales.dto.shop.ShopResponse;
import com.example.sales.exception.BusinessException;
import com.example.sales.model.Branch;
import com.example.sales.model.Shop;
import com.example.sales.model.ShopUser;
import com.example.sales.repository.BranchRepository;
import com.example.sales.repository.ShopRepository;
import com.example.sales.repository.ShopUserRepository;
import com.example.sales.security.CustomUserDetails;
import com.example.sales.security.PermissionUtils;
import lombok.RequiredArgsConstructor;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class ShopService extends BaseService {

    private final ShopRepository shopRepository;
    private final AuditLogService auditLogService;
    private final ShopUserRepository shopUserRepository;
    private final BranchRepository branchRepository;
    private final ShopCache shopCache;

    public Shop createShop(String userId, ShopRequest request, String logoUrl) {
        if (shopRepository.existsByNameAndDeletedFalse(request.getName())) {
            throw new BusinessException(ApiCode.SHOP_NAME_EXISTS);
        }
        if (shopRepository.findByOwnerIdAndDeletedFalse(userId).isPresent()) {
            throw new BusinessException(ApiCode.SHOP_ALREADY_EXISTS);
        }

        Shop shop = new Shop();
        shop.setName(request.getName());
        shop.setType(request.getType());
        shop.setAddress(request.getAddress());
        shop.setPhone(request.getPhone());
        shop.setLogoUrl(logoUrl);
        shop.setOwnerId(userId);

        Shop savedShop = shopRepository.save(shop); // Đổi tên biến để rõ ràng hơn

        // ✅ Tạo chi nhánh mặc định
        Branch defaultBranch = Branch.builder()
                .shopId(savedShop.getId())
                .name("Chi nhánh chính") // Tên chi nhánh mặc định
                .address(request.getAddress()) // Lấy địa chỉ từ request của shop
                .phone(request.getPhone()) // Lấy số điện thoại từ request của shop
                .build();
        Branch savedBranch = branchRepository.save(defaultBranch); // Lưu chi nhánh

        // ✅ Cập nhật ShopUser để liên kết với chi nhánh mặc định
        ShopUser shopUser = ShopUser.builder()
                .shopId(savedShop.getId())
                .userId(userId)
                .role(ShopRole.OWNER)
                .branchId(savedBranch.getId())
                .permissions(PermissionUtils.getDefaultPermissions(ShopRole.OWNER))
                .build();
        shopUserRepository.save(shopUser);

        auditLogService.log(userId, savedShop.getId(), savedShop.getId(), "SHOP", "CREATED",
                String.format("Tạo cửa hàng: %s (%s)", savedShop.getName(), savedShop.getType()));

        return savedShop;
    }

    public Shop updateShop(String ownerId, ShopRequest request) {
        Shop shop = shopCache.getShopByOwner(ownerId);

        shop.setName(request.getName());
        shop.setType(request.getType());
        shop.setAddress(request.getAddress());
        shop.setPhone(request.getPhone());

        Shop saved = shopRepository.save(shop);
        auditLogService.log(null, saved.getId(), saved.getId(), "SHOP", "UPDATED",
                String.format("Cập nhật cửa hàng: %s (%s)", saved.getName(), saved.getType()));
        return saved;
    }

    public void deleteShop(String ownerId) {
        Shop shop = shopCache.getShopByOwner(ownerId);
        shop.setDeleted(true);
        shopRepository.save(shop);
        auditLogService.log(null, shop.getId(), shop.getId(), "SHOP", "DELETED",
                String.format("Xoá mềm cửa hàng: %s", shop.getName()));
    }

    @Cacheable(value = "shops", key = "#shopId")
    public Shop getShopById(String shopId) {
        return checkShopExists(shopRepository, shopId);
    }

    public Shop save(Shop shop) {
        return shopRepository.save(shop);
    }

    public Object getShopResponse(CustomUserDetails user, Shop shop) {
        if (user.getRole() == UserRole.ROLE_ADMIN) {
            return ShopAdminResponse.builder()
                    .id(shop.getId())
                    .name(shop.getName())
                    .type(shop.getType())
                    .address(shop.getAddress())
                    .phone(shop.getPhone())
                    .logoUrl(shop.getLogoUrl())
                    .active(shop.isActive())
                    .plan(shop.getPlan())
                    .currency(shop.getCurrency())
                    .timezone(shop.getTimezone())
                    .orderPrefix(shop.getOrderPrefix())
                    .planExpiry(shop.getPlanExpiry())
                    .build();
        } else {
            return ShopResponse.builder()
                    .id(shop.getId())
                    .name(shop.getName())
                    .type(shop.getType())
                    .address(shop.getAddress())
                    .phone(shop.getPhone())
                    .logoUrl(shop.getLogoUrl())
                    .active(shop.isActive())
                    .plan(shop.getPlan())
                    .currency(shop.getCurrency())
                    .build();
        }
    }
}

// File: src/main/java/com/example/sales/service/ShopUserService.java
package com.example.sales.service;

import com.example.sales.cache.ShopUserCache;
import com.example.sales.constant.ApiCode;
import com.example.sales.constant.ShopRole;
import com.example.sales.dto.shop.ShopSimpleResponse;
import com.example.sales.exception.BusinessException;
import com.example.sales.model.Branch;
import com.example.sales.model.Shop;
import com.example.sales.model.ShopUser;
import com.example.sales.repository.BranchRepository;
import com.example.sales.repository.ShopRepository;
import com.example.sales.repository.ShopUserRepository;
import com.example.sales.security.PermissionUtils;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class ShopUserService extends BaseService {

    private final ShopUserRepository shopUserRepository;
    private final ShopRepository shopRepository;
    private final AuditLogService auditLogService;
    private final BranchRepository branchRepository;
    private final ShopUserCache shopUserCache;

    public void requireAnyRole(String shopId, String userId, ShopRole... roles) {
        ShopRole actual = shopUserCache.getUserRoleInShop(shopId, userId);
        if (Arrays.stream(roles).noneMatch(role -> role == actual)) {
            throw new BusinessException(ApiCode.UNAUTHORIZED);
        }
    }

    public void addUser(String shopId, String userId, ShopRole role, String branchId, String performedByUserId) {
        validateBranchRoleHierarchy(shopId, branchId, performedByUserId, userId);
        Shop shop = shopRepository.findByIdAndDeletedFalse(shopId)
                .orElseThrow(() -> new BusinessException(ApiCode.SHOP_NOT_FOUND));
        if (!shop.isActive()) {
            throw new BusinessException(ApiCode.SHOP_INACTIVE);
        }

        Optional<ShopUser> existingShopUser = shopUserRepository.findByShopIdAndUserIdAndBranchId(shopId, userId, branchId);

        if (existingShopUser.isPresent()) {
            ShopUser shopUser = existingShopUser.get();
            if (!shopUser.isDeleted()) {
                throw new BusinessException(ApiCode.USER_ALREADY_IN_SHOP);
            } else {
                shopUser.setDeleted(false);
                shopUser.setRole(role);
                shopUser.setPermissions(PermissionUtils.getDefaultPermissions(role));
                shopUserRepository.save(shopUser);
                auditLogService.log(performedByUserId, shopId, shopUser.getId(), "SHOP_USER", "REACTIVATED",
                        String.format("Tái kích hoạt người dùng %s vào chi nhánh %s của cửa hàng %s với vai trò %s", userId, branchId, shopId, role));
            }
        } else {
            ShopUser newShopUser = ShopUser.builder()
                    .shopId(shopId)
                    .userId(userId)
                    .role(role)
                    .branchId(branchId)
                    .permissions(PermissionUtils.getDefaultPermissions(role))
                    .build();
            shopUserRepository.save(newShopUser);
            auditLogService.log(performedByUserId, shopId, newShopUser.getId(), "SHOP_USER", "ADDED",
                    String.format("Thêm người dùng %s vào chi nhánh %s của cửa hàng %s với vai trò %s", userId, branchId, shopId, role));
        }
    }

    public void removeUser(String shopId, String userId, String branchId, String performedByUserId) {
        validateBranchRoleHierarchy(shopId, branchId, performedByUserId, userId);
        ShopUser shopUser = shopUserRepository.findByUserIdAndShopIdAndBranchIdAndDeletedFalse(userId, shopId, branchId)
                .orElseThrow(() -> new BusinessException(ApiCode.NOT_FOUND));
        shopUser.setDeleted(true);
        shopUserRepository.save(shopUser);

        auditLogService.log(performedByUserId, shopId, shopUser.getId(), "SHOP_USER", "REMOVED",
                String.format("Xoá người dùng %s khỏi chi nhánh %s của cửa hàng %s", userId, branchId, shopId));
    }

    // ✅ Phương thức mới để xóa user khỏi shop, không quan tâm branch
    public void removeUserFromShop(String shopId, String userId, String performedByUserId) {
        if (userId.equals(performedByUserId)) {
            auditLogService.log(performedByUserId, shopId, userId, "SHOP_USER", "UNAUTHORIZED",
                    "Người dùng không thể xóa chính mình khỏi cửa hàng");
            throw new BusinessException(ApiCode.UNAUTHORIZED);
        }

        List<ShopUser> targetShopUsers = shopUserRepository.findByUserIdAndShopIdAndDeletedFalse(userId, shopId);
        if (targetShopUsers.isEmpty()) {
            auditLogService.log(performedByUserId, shopId, userId, "SHOP_USER", "NOT_FOUND",
                    String.format("Người dùng %s không tồn tại trong cửa hàng %s", userId, shopId));
            throw new BusinessException(ApiCode.NOT_FOUND);
        }

        // Lấy các bản ghi ShopUser của người thực hiện trong shop
        List<ShopUser> performerShopUsers = shopUserRepository.findByUserIdAndShopIdAndDeletedFalse(performedByUserId, shopId);
        if (performerShopUsers.isEmpty()) {
            auditLogService.log(performedByUserId, shopId, userId, "SHOP_USER", "ACCESS_DENIED",
                    String.format("Người dùng %s không có quyền thao tác trong cửa hàng %s", performedByUserId, shopId));
            throw new BusinessException(ApiCode.UNAUTHORIZED);
        }

        for (ShopUser targetSU : targetShopUsers) {
            ShopUser performer = performerShopUsers.stream()
                    .filter(p -> p.getBranchId().equals(targetSU.getBranchId()))
                    .findFirst()
                    .orElse(null);

            if (performer == null) {
                auditLogService.log(performedByUserId, shopId, userId, "SHOP_USER", "ACCESS_DENIED",
                        String.format("Người dùng %s không có quyền thao tác trong chi nhánh %s của cửa hàng %s", performedByUserId, targetSU.getBranchId(), shopId));
                throw new BusinessException(ApiCode.ACCESS_DENIED);
            }

            ensureCanModifyRole(performer.getRole(), targetSU.getRole());
            targetSU.setDeleted(true);
        }

        shopUserRepository.saveAll(targetShopUsers);

        auditLogService.log(performedByUserId, shopId, userId, "SHOP_USER", "REMOVED_FROM_SHOP",
                String.format("Xoá người dùng %s khỏi tất cả các chi nhánh của cửa hàng %s", userId, shopId));
    }


    public Page<ShopSimpleResponse> getShopsForUser(String userId, Pageable pageable) {
        return shopUserRepository.findByUserIdAndDeletedFalse(userId, pageable)
                .map(su -> {
                    Optional<Shop> shopOpt = shopRepository.findByIdAndDeletedFalse(su.getShopId());
                    Optional<Branch> branchOpt = branchRepository.findByIdAndDeletedFalse(su.getBranchId());

                    if (shopOpt.isEmpty() || branchOpt.isEmpty()) return null;

                    Shop shop = shopOpt.get();
                    Branch branch = branchOpt.get();

                    return ShopSimpleResponse.builder()
                            .id(shop.getId())
                            .name(shop.getName())
                            .type(shop.getType())
                            .logoUrl(shop.getLogoUrl())
                            .active(shop.isActive())
                            .role(su.getRole())
                            .branchId(branch.getId())
                            .branchName(branch.getName())
                            .branchAddress(branch.getAddress())
                            .build();
                });
    }


    private void ensureCanModifyRole(ShopRole actorRole, ShopRole targetRole) {
        if (actorRole == ShopRole.MANAGER &&
                (targetRole == ShopRole.OWNER || targetRole == ShopRole.ADMIN || targetRole == ShopRole.MANAGER)) {
            auditLogService.log(null, null, null, "ROLE_MODIFICATION", "DENIED",
                    "MANAGER attempted to modify a higher role.");
            throw new BusinessException(ApiCode.ACCESS_DENIED);
        }

        if (actorRole.ordinal() < targetRole.ordinal()) {
            auditLogService.log(null, null, null, "ROLE_MODIFICATION", "DENIED",
                    String.format("User with role %s attempted to modify user with role %s.", actorRole, targetRole));
            throw new BusinessException(ApiCode.ACCESS_DENIED);
        }
    }


    public ShopRole getUserRoleInBranch(String shopId, String userId, String branchId) {
        return shopUserRepository.findByUserIdAndShopIdAndBranchIdAndDeletedFalse(userId, shopId, branchId)
                .map(ShopUser::getRole)
                .orElseThrow(() -> new BusinessException(ApiCode.UNAUTHORIZED));
    }

    public void validateBranchRoleHierarchy(String shopId, String branchId, String actorUserId, String targetUserId) {
        // Lấy role người thực hiện (actor) tại branch
        ShopRole actorRole = getUserRoleInBranch(shopId, actorUserId, branchId);

        // Lấy role người bị thao tác (target)
        ShopRole targetRole = getUserRoleInBranch(shopId, targetUserId, branchId);

        // Thực hiện logic so sánh
        ensureCanModifyRole(actorRole, targetRole);
    }

}

// File: src/main/java/com/example/sales/service/TableService.java
package com.example.sales.service;

import com.example.sales.constant.ApiCode;
import com.example.sales.constant.ShopRole;
import com.example.sales.constant.TableStatus;
import com.example.sales.dto.table.TableRequest;
import com.example.sales.dto.table.TableResponse;
import com.example.sales.exception.BusinessException;
import com.example.sales.exception.ResourceNotFoundException;
import com.example.sales.model.Shop;
import com.example.sales.model.Table;
import com.example.sales.repository.ShopRepository;
import com.example.sales.repository.TableRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

@Service
@RequiredArgsConstructor
public class TableService {

    private final TableRepository tableRepository;
    private final ShopRepository shopRepository;
    private final AuditLogService auditLogService;
    private final ShopUserService shopUserService;

    @Transactional
    public TableResponse create(String userId, TableRequest request) {
        String shopId = request.getShopId();
        String branchId = request.getBranchId();

        // Kiểm tra quyền truy cập
        shopUserService.requireAnyRole(shopId, userId, ShopRole.OWNER);

        // Kiểm tra cửa hàng tồn tại
        Shop shop = shopRepository.findByIdAndDeletedFalse(shopId)
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.SHOP_NOT_FOUND));

        // Kiểm tra trùng lặp tên bàn
        if (tableRepository.findByShopIdAndBranchIdAndDeletedFalse(shopId, branchId)
                .stream().anyMatch(table -> table.getName().equalsIgnoreCase(request.getName()))) {
            throw new BusinessException(ApiCode.TABLE_NAME_EXISTS);
        }

        // Kiểm tra capacity hợp lệ
        if (request.getCapacity() != null && request.getCapacity() <= 0) {
            throw new BusinessException(ApiCode.INVALID_CAPACITY);
        }

        Table table = Table.builder()
                .name(request.getName())
                .shopId(shopId)
                .branchId(branchId)
                .status(Optional.ofNullable(request.getStatus()).orElse(TableStatus.AVAILABLE))
                .capacity(request.getCapacity())
                .note(request.getNote())
                .build();

        Table saved = tableRepository.save(table);
        auditLogService.log(userId, shopId, saved.getId(), "TABLE", "CREATED",
                String.format("Tạo bàn: %s (Chi nhánh: %s)", saved.getName(), saved.getBranchId()));
        return toResponse(saved, shop);
    }

    public Page<TableResponse> getByShop(String userId, String shopId, String branchId, Pageable pageable) {
        // Kiểm tra quyền truy cập
        shopUserService.requireAnyRole(shopId, userId, ShopRole.OWNER, ShopRole.STAFF);

        // Kiểm tra cửa hàng tồn tại
        Shop shop = shopRepository.findByIdAndDeletedFalse(shopId)
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.SHOP_NOT_FOUND));

        // Lấy danh sách bàn với phân trang
        return tableRepository.findByShopIdAndBranchIdAndDeletedFalse(shopId, branchId, pageable)
                .map(table -> toResponse(table, shop));
    }

    @Transactional
    public TableResponse updateStatus(String userId, String tableId, TableStatus status) {
        // Kiểm tra quyền truy cập
        shopUserService.requireAnyRole(null, userId, ShopRole.OWNER, ShopRole.STAFF);

        Table table = tableRepository.findByIdAndDeletedFalse(tableId)
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.TABLE_NOT_FOUND));

        table.setStatus(status);
        Table saved = tableRepository.save(table);
        auditLogService.log(userId, table.getShopId(), saved.getId(), "TABLE", "STATUS_UPDATED",
                String.format("Cập nhật trạng thái bàn: %s → %s", table.getName(), status));
        return toResponse(saved, shopRepository.findByIdAndDeletedFalse(table.getShopId()).orElse(null));
    }

    @Transactional
    public TableResponse updateTable(String userId, String tableId, TableRequest request) {
        // Kiểm tra quyền truy cập
        shopUserService.requireAnyRole(request.getShopId(), userId, ShopRole.OWNER);

        Table table = tableRepository.findByIdAndDeletedFalse(tableId)
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.TABLE_NOT_FOUND));

        // Kiểm tra bàn không đang được sử dụng
        if (table.getStatus() == TableStatus.OCCUPIED) {
            throw new BusinessException(ApiCode.TABLE_OCCUPIED);
        }

        // Kiểm tra cửa hàng tồn tại
        Shop shop = shopRepository.findByIdAndDeletedFalse(request.getShopId())
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.SHOP_NOT_FOUND));

        // Kiểm tra trùng lặp tên bàn
        if (!table.getName().equalsIgnoreCase(request.getName()) &&
                tableRepository.findByShopIdAndBranchIdAndDeletedFalse(request.getShopId(), request.getBranchId())
                        .stream().anyMatch(t -> t.getName().equalsIgnoreCase(request.getName()))) {
            throw new BusinessException(ApiCode.TABLE_NAME_EXISTS);
        }

        // Kiểm tra capacity hợp lệ
        if (request.getCapacity() != null && request.getCapacity() <= 0) {
            throw new BusinessException(ApiCode.INVALID_CAPACITY);
        }

        // Cập nhật thông tin bàn
        table.setName(request.getName());
        table.setShopId(request.getShopId());
        table.setBranchId(request.getBranchId());
        table.setCapacity(request.getCapacity());
        table.setNote(request.getNote());
        table.setStatus(Optional.ofNullable(request.getStatus()).orElse(TableStatus.AVAILABLE));

        Table saved = tableRepository.save(table);
        auditLogService.log(userId, table.getShopId(), saved.getId(), "TABLE", "UPDATED",
                String.format("Cập nhật thông tin bàn: %s", table.getName()));
        return toResponse(saved, shop);
    }

    @Transactional
    public void deleteTable(String userId, String tableId) {
        // Kiểm tra quyền truy cập
        shopUserService.requireAnyRole(null, userId, ShopRole.OWNER);

        Table table = tableRepository.findByIdAndDeletedFalse(tableId)
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.TABLE_NOT_FOUND));

        // Kiểm tra bàn không đang được sử dụng
        if (table.getStatus() == TableStatus.OCCUPIED) {
            throw new BusinessException(ApiCode.TABLE_OCCUPIED);
        }

        table.setDeleted(true);
        tableRepository.save(table);
        auditLogService.log(userId, table.getShopId(), tableId, "TABLE", "DELETED",
                String.format("Xóa bàn: %s", table.getName()));
    }

    private TableResponse toResponse(Table table, Shop shop) {
        return TableResponse.builder()
                .id(table.getId())
                .name(table.getName())
                .status(table.getStatus())
                .shopId(table.getShopId())
                .branchId(table.getBranchId())
                .shopName(shop != null ? shop.getName() : null)
                .capacity(table.getCapacity())
                .note(table.getNote())
                .currentOrderId(table.getCurrentOrderId())
                .build();
    }
}

// File: src/main/java/com/example/sales/service/TokenService.java
package com.example.sales.service;

import com.example.sales.constant.ApiCode;
import com.example.sales.exception.BusinessException;
import com.example.sales.model.RefreshToken;
import com.example.sales.model.User;
import com.example.sales.repository.RefreshTokenRepository;
import com.example.sales.repository.UserRepository;
import com.example.sales.security.JwtUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.Date;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class TokenService {

    private final RefreshTokenRepository refreshTokenRepository;
    private final UserRepository userRepository;
    private final JwtUtil jwtUtil;

    public RefreshToken createRefreshToken(User user) {
        RefreshToken token = new RefreshToken();
        token.setToken(UUID.randomUUID().toString());
        token.setUserId(user.getId());
        token.setExpiryDate(new Date(System.currentTimeMillis() + 7 * 24 * 60 * 60 * 1000)); // 7 ngày

        return refreshTokenRepository.save(token);
    }

    public String refreshAccessToken(String refreshTokenValue) {
        RefreshToken token = refreshTokenRepository.findByToken(refreshTokenValue)
                .orElseThrow(() -> new BusinessException(ApiCode.REFRESH_TOKEN_INVALID));

        if (token.getExpiryDate().before(new Date())) {
            refreshTokenRepository.delete(token);
            throw new BusinessException(ApiCode.REFRESH_TOKEN_EXPIRED);
        }

        User user = userRepository.findByIdAndDeletedFalse(token.getUserId())
                .orElseThrow(() -> new BusinessException(ApiCode.USER_NOT_FOUND));

        return jwtUtil.generateToken(user);
    }

    public void revokeToken(String refreshToken) {
        refreshTokenRepository.findByToken(refreshToken)
                .ifPresent(refreshTokenRepository::delete);
    }
}

// File: src/main/java/com/example/sales/service/UserService.java
package com.example.sales.service;

import com.example.sales.constant.ApiCode;
import com.example.sales.exception.BusinessException;
import com.example.sales.model.User;
import com.example.sales.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public User getCurrentUser(String userId) {
        return userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ApiCode.USER_NOT_FOUND));
    }

    public User updateProfile(String userId, String fullName, String phone, String businessType) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ApiCode.USER_NOT_FOUND));
        user.setFullName(fullName);
        user.setPhone(phone);
        user.setBusinessType(businessType);
        return userRepository.save(user);
    }

    public void changePassword(String userId, String currentPassword, String newPassword) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(ApiCode.USER_NOT_FOUND));
        if (!passwordEncoder.matches(currentPassword, user.getPassword())) {
            throw new BusinessException(ApiCode.INCORRECT_PASSWORD);
        }
        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);
    }
}

// File: src/main/java/com/example/sales/helper/CustomerSearchHelper.java
package com.example.sales.helper;

import com.example.sales.dto.customer.CustomerSearchRequest;
import com.example.sales.model.Customer;
import org.bson.Document;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.aggregation.*;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import static org.springframework.data.mongodb.core.aggregation.Aggregation.*;

@Component
public class CustomerSearchHelper {

    private final MongoTemplate mongoTemplate;

    public CustomerSearchHelper(MongoTemplate mongoTemplate) {
        this.mongoTemplate = mongoTemplate;
    }

    public List<Customer> search(String userId, CustomerSearchRequest req, Pageable pageable) {
        Aggregation agg = newAggregation(
                buildMatch(userId, req),
                sort(Sort.Direction.DESC, "_id"),
                skip((long) pageable.getPageNumber() * pageable.getPageSize()),
                limit(pageable.getPageSize())
        );

        return mongoTemplate.aggregate(agg, "customers", Customer.class).getMappedResults();
    }

    public long counts(String userId, CustomerSearchRequest req) {
        Aggregation countAgg = newAggregation(
                buildMatch(userId, req),
                count().as("total")
        );

        return Optional.of(
                mongoTemplate.aggregate(countAgg, "customers", Document.class)
                        .getUniqueMappedResult()
        ).map(d -> ((Number) d.get("total")).longValue()).orElse(0L);
    }

    public List<Customer> exportAll(String userId, CustomerSearchRequest req) {
        Aggregation agg = newAggregation(
                buildMatch(userId, req),
                sort(Sort.Direction.ASC, "name")
        );

        return mongoTemplate.aggregate(agg, "customers", Customer.class).getMappedResults();
    }

    private MatchOperation buildMatch(String userId, CustomerSearchRequest req) {
        String keyword = Optional.ofNullable(req.getKeyword()).orElse("").trim();

        Criteria base = Criteria.where("userId").is(userId);
        List<Criteria> andConditions = new ArrayList<>();
        andConditions.add(base);

        // keyword
        if (!keyword.isEmpty()) {
            andConditions.add(new Criteria().orOperator(
                    Criteria.where("name").regex(keyword, "i"),
                    Criteria.where("email").regex(keyword, "i"),
                    Criteria.where("phone").regex(keyword, "i")
            ));
        }

        // filter ngày tạo
        if (req.getFromDate() != null || req.getToDate() != null) {
            Criteria dateCriteria = Criteria.where("createdAt");
            if (req.getFromDate() != null) {
                dateCriteria = dateCriteria.gte(req.getFromDate().atStartOfDay());
            }
            if (req.getToDate() != null) {
                dateCriteria = dateCriteria.lte(req.getToDate().atTime(23, 59, 59));
            }
            andConditions.add(dateCriteria);
        }

        return match(new Criteria().andOperator(andConditions.toArray(new Criteria[0])));
    }
}

// File: src/main/java/com/example/sales/helper/ProductSearchHelper.java
package com.example.sales.helper;

import com.example.sales.dto.product.ProductSearchRequest;
import com.example.sales.model.Product;
import lombok.RequiredArgsConstructor;
import org.bson.Document;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.aggregation.*;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.stereotype.Component;

import java.util.*;

import static org.springframework.data.mongodb.core.aggregation.Aggregation.*;

@Component
@RequiredArgsConstructor
public class ProductSearchHelper {

    private final MongoTemplate mongoTemplate;

    public List<Product> search(String shopId, String branchId, ProductSearchRequest req, Pageable pageable) {
        Aggregation agg = newAggregation(
                buildMatch(shopId, branchId, req),
                sort(Sort.Direction.fromString(req.getSortDir()), req.getSortBy()),
                skip((long) pageable.getPageNumber() * pageable.getPageSize()),
                limit(pageable.getPageSize())
        );

        return mongoTemplate.aggregate(agg, "products", Product.class).getMappedResults();
    }

    public long counts(String shopId, String branchId, ProductSearchRequest req) {
        Aggregation agg = newAggregation(
                buildMatch(shopId, branchId, req),
                count().as("total")
        );

        return Optional.of(
                mongoTemplate.aggregate(agg, "products", Document.class).getUniqueMappedResult()
        ).map(d -> ((Number) d.get("total")).longValue()).orElse(0L);
    }

    private MatchOperation buildMatch(String shopId, String branchId, ProductSearchRequest req) {
        List<Criteria> criteria = new ArrayList<>();
        criteria.add(Criteria.where("shopId").is(shopId));
        if (branchId != null && !branchId.isBlank()) {
            criteria.add(Criteria.where("branchId").is(branchId));
        }
        if (req.getKeyword() != null && !req.getKeyword().isBlank()) {
            String pattern = ".*" + req.getKeyword().trim() + ".*";
            criteria.add(new Criteria().orOperator(
                    Criteria.where("name").regex(pattern, "i"),
                    Criteria.where("category").regex(pattern, "i")
            ));
        }

        if (req.getCategory() != null && !req.getCategory().isBlank()) {
            criteria.add(Criteria.where("category").is(req.getCategory()));
        }

        if (req.getActive() != null) {
            criteria.add(Criteria.where("active").is(req.getActive()));
        }

        if (req.getMinPrice() != null) {
            criteria.add(Criteria.where("price").gte(req.getMinPrice()));
        }

        if (req.getMaxPrice() != null) {
            criteria.add(Criteria.where("price").lte(req.getMaxPrice()));
        }

        return match(new Criteria().andOperator(criteria.toArray(new Criteria[0])));
    }
}

// File: src/main/java/com/example/sales/service/impl/ProductServiceImpl.java
package com.example.sales.service.impl;

import com.example.sales.cache.ProductCache;
import com.example.sales.constant.ApiCode;
import com.example.sales.constant.ShopType;
import com.example.sales.dto.product.ProductRequest;
import com.example.sales.dto.product.ProductResponse;
import com.example.sales.exception.BusinessException;
import com.example.sales.model.BranchProduct;
import com.example.sales.model.Product;
import com.example.sales.model.Shop;
import com.example.sales.repository.BranchProductRepository;
import com.example.sales.repository.ProductRepository;
import com.example.sales.repository.ShopRepository;
import com.example.sales.service.AuditLogService;
import com.example.sales.service.BaseService;
import com.example.sales.service.ProductService;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.time.LocalDateTime;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Triển khai dịch vụ quản lý sản phẩm với mô hình Product và BranchProduct.
 */
@Service
@RequiredArgsConstructor
public class ProductServiceImpl extends BaseService implements ProductService {
    private final ProductRepository productRepository;
    private final BranchProductRepository branchProductRepository; // New repository
    private final ShopRepository shopRepository;
    private final AuditLogService auditLogService;
    private final ProductCache productCache; // Cache for product operations

    @Override
    public ProductResponse createProduct(String shopId, String branchId, ProductRequest request) {
        Shop shop = shopRepository.findByIdAndDeletedFalse(shopId)
                .orElseThrow(() -> new BusinessException(ApiCode.SHOP_NOT_FOUND));

        // 1. Find or Create Master Product
        // Generate SKU if not provided or if it's blank
        String sku = StringUtils.hasText(request.getSku())
                ? request.getSku()
                : UUID.randomUUID().toString();

        Optional<Product> existingProduct = productRepository.findByShopIdAndSkuAndDeletedFalse(shopId, sku);
        Product product;
        if (existingProduct.isPresent()) {
            product = existingProduct.get();
            // Update master product details if provided in request
            product.setName(request.getName());
            product.setCategory(request.getCategory());
            productRepository.save(product);
        } else {
            // Create a new master product definition
            product = Product.builder()
                    .shopId(shopId)
                    .name(request.getName())
                    .category(request.getCategory())
                    .sku(sku)
                    .build();
            product = productRepository.save(product);
        }

        // 2. Create BranchProduct
        // Check if BranchProduct already exists for this productId and branchId
        if (branchProductRepository.findByProductIdAndBranchIdAndDeletedFalse(product.getId(), branchId).isPresent()) {
            throw new BusinessException(ApiCode.VALIDATION_ERROR);
        }

        BranchProduct branchProduct = BranchProduct.builder()
                .productId(product.getId())
                .shopId(shopId)
                .branchId(branchId)
                .quantity(requiresInventory(shop.getType()) ? request.getQuantity() : 0)
                .price(request.getPrice())
                .unit(request.getUnit())
                .imageUrl(request.getImageUrl())
                .description(request.getDescription())
                .activeInBranch(request.isActive()) // Map active from request to activeInBranch
                .build();

        branchProduct = branchProductRepository.save(branchProduct);

        auditLogService.log(null, shopId, branchProduct.getId(), "BRANCH_PRODUCT", "CREATED",
                String.format("Tạo sản phẩm '%s' (SKU: %s) tại chi nhánh %s. ID BranchProduct: %s",
                        product.getName(), product.getSku(), branchProduct.getBranchId(), branchProduct.getId()));

        return toResponse(branchProduct, product);
    }

    @Override
    public ProductResponse updateProduct(String userId, String shopId, String branchId, String id, ProductRequest request) {
        // id ở đây là id của BranchProduct
        BranchProduct branchProduct = branchProductRepository.findByIdAndShopIdAndBranchIdAndDeletedFalse(id, shopId, branchId)
                .orElseThrow(() -> new BusinessException(ApiCode.PRODUCT_NOT_FOUND));

        Product product = productRepository.findByIdAndShopIdAndDeletedFalse(branchProduct.getProductId(), shopId)
                .orElseThrow(() -> new BusinessException(ApiCode.PRODUCT_NOT_FOUND)); // Should not happen if data is consistent

        // Save old values for audit log from BranchProduct
        double oldPrice = branchProduct.getPrice();
        int oldQuantity = branchProduct.getQuantity();
        boolean oldActiveInBranch = branchProduct.isActiveInBranch();

        // Save old values for audit log from Product
        String oldName = product.getName();
        String oldCategory = product.getCategory();

        Shop shop = shopRepository.findByIdAndDeletedFalse(shopId)
                .orElseThrow(() -> new BusinessException(ApiCode.SHOP_NOT_FOUND));

        // Update Master Product fields (if changed via this request)
        if (!product.getName().equals(request.getName())) {
            product.setName(request.getName());
        }
        if (!product.getCategory().equals(request.getCategory())) {
            product.setCategory(request.getCategory());
        }
        // SKU is usually not updated via product request
        product = productRepository.save(product); // Save master product changes

        // Update BranchProduct fields
        branchProduct.setPrice(request.getPrice());
        branchProduct.setQuantity(requiresInventory(shop.getType()) ? request.getQuantity() : 0);
        branchProduct.setUnit(request.getUnit());
        branchProduct.setImageUrl(request.getImageUrl());
        branchProduct.setDescription(request.getDescription());
        branchProduct.setActiveInBranch(request.isActive()); // Update active status for this branch
        branchProduct.setUpdatedAt(LocalDateTime.now());

        branchProduct = branchProductRepository.save(branchProduct);

        // Audit logs for changes
        if (!oldName.equals(request.getName())) {
            auditLogService.log(userId, shopId, product.getId(), "PRODUCT", "NAME_CHANGED",
                    String.format("Thay đổi tên sản phẩm chung từ '%s' → '%s'", oldName, request.getName()));
        }
        if (!oldCategory.equals(request.getCategory())) {
            auditLogService.log(userId, shopId, product.getId(), "PRODUCT", "CATEGORY_CHANGED",
                    String.format("Thay đổi danh mục sản phẩm chung từ '%s' → '%s'", oldCategory, request.getCategory()));
        }
        if (oldPrice != request.getPrice()) {
            auditLogService.log(userId, shopId, branchProduct.getId(), "BRANCH_PRODUCT", "PRICE_CHANGED",
                    String.format("Thay đổi giá sản phẩm '%s' từ %.2f → %.2f tại chi nhánh %s", product.getName(), oldPrice, request.getPrice(), branchProduct.getBranchId()));
        }
        if (requiresInventory(shop.getType()) && oldQuantity != request.getQuantity()) {
            auditLogService.log(userId, shopId, branchProduct.getId(), "BRANCH_PRODUCT", "QUANTITY_CHANGED",
                    String.format("Thay đổi tồn kho sản phẩm '%s' từ %d → %d tại chi nhánh %s", product.getName(), oldQuantity, request.getQuantity(), branchProduct.getBranchId()));
        }
        if (oldActiveInBranch != request.isActive()) {
            String action = request.isActive() ? "ACTIVATED" : "DEACTIVATED";
            auditLogService.log(userId, shopId, branchProduct.getId(), "BRANCH_PRODUCT", action,
                    String.format("%s sản phẩm '%s' tại chi nhánh %s",
                            request.isActive() ? "Kích hoạt bán" : "Ngưng bán", product.getName(), branchProduct.getBranchId()));
        }

        return toResponse(branchProduct, product);
    }

    @Override
    public void deleteProduct(String userId, String shopId, String branchId, String id) {
        BranchProduct branchProduct = branchProductRepository.findByIdAndShopIdAndBranchIdAndDeletedFalse(id, shopId, branchId)
                .orElseThrow(() -> new BusinessException(ApiCode.PRODUCT_NOT_FOUND));

        branchProduct.setDeleted(true);
        branchProduct.setUpdatedAt(LocalDateTime.now());
        branchProductRepository.save(branchProduct);

        Product product = productRepository.findByIdAndShopIdAndDeletedFalse(branchProduct.getProductId(), shopId)
                .orElse(null); // Master product might already be deleted or not found for some reason

        String productName = (product != null) ? product.getName() : "Unknown Product";
        String productSku = (product != null) ? product.getSku() : "Unknown SKU";

        auditLogService.log(userId, shopId, branchProduct.getId(), "BRANCH_PRODUCT", "DELETED",
                String.format("Xoá sản phẩm '%s' (SKU: %s) tại chi nhánh %s. ID BranchProduct: %s",
                        productName, productSku, branchProduct.getBranchId(), branchProduct.getId()));
    }

    @Override
    public ProductResponse getProduct(String shopId, String branchId, String id) {
        BranchProduct branchProduct = branchProductRepository.findByIdAndShopIdAndBranchIdAndDeletedFalse(id, shopId, branchId)
                .orElseThrow(() -> new BusinessException(ApiCode.PRODUCT_NOT_FOUND));

        Product product = productRepository.findByIdAndShopIdAndDeletedFalse(branchProduct.getProductId(), shopId)
                .orElseThrow(() -> new BusinessException(ApiCode.PRODUCT_NOT_FOUND));

        return toResponse(branchProduct, product);
    }

    @Override
    public ProductResponse toggleActive(String userId, String shopId, String branchId, String branchProductId) {
        BranchProduct branchProduct = branchProductRepository.findByIdAndShopIdAndBranchIdAndDeletedFalse(branchProductId, shopId, branchId)
                .orElseThrow(() -> new BusinessException(ApiCode.PRODUCT_NOT_FOUND));

        branchProduct.setActiveInBranch(!branchProduct.isActiveInBranch());
        branchProduct.setUpdatedAt(LocalDateTime.now());
        branchProduct = branchProductRepository.save(branchProduct);

        Product product = productRepository.findByIdAndShopIdAndDeletedFalse(branchProduct.getProductId(), shopId)
                .orElse(null);

        String productName = (product != null) ? product.getName() : "Unknown Product";
        String productSku = (product != null) ? product.getSku() : "Unknown SKU";

        String action = branchProduct.isActiveInBranch() ? "ACTIVATED" : "DEACTIVATED";
        auditLogService.log(userId, shopId, branchProduct.getId(), "BRANCH_PRODUCT", action,
                String.format("%s sản phẩm '%s' (SKU: %s) tại chi nhánh %s. ID BranchProduct: %s",
                        branchProduct.isActiveInBranch() ? "Kích hoạt bán" : "Ngưng bán",
                        productName, productSku, branchProduct.getBranchId(), branchProduct.getId()));

        return toResponse(branchProduct, product);
    }

    @Override
    public List<ProductResponse> getLowStockProducts(String shopId, String branchId, int threshold) {
        Shop shop = shopRepository.findByIdAndDeletedFalse(shopId)
                .orElseThrow(() -> new BusinessException(ApiCode.SHOP_NOT_FOUND));

        if (!requiresInventory(shop.getType())) {
            return List.of();
        }

        List<BranchProduct> lowStockBranchProducts;
        if (StringUtils.hasText(branchId)) {
            lowStockBranchProducts = branchProductRepository.findByShopIdAndBranchIdAndQuantityLessThanAndDeletedFalse(shopId, branchId, threshold);
        } else {
            lowStockBranchProducts = branchProductRepository.findByShopIdAndQuantityLessThanAndDeletedFalse(shopId, threshold);
        }

        Set<String> productIds = lowStockBranchProducts.stream()
                .map(BranchProduct::getProductId)
                .collect(Collectors.toSet());

        Map<String, Product> productsMap = productRepository.findAllById(productIds).stream()
                .collect(Collectors.toMap(Product::getId, Function.identity()));

        return lowStockBranchProducts.stream()
                .map(bp -> toResponse(bp, productsMap.get(bp.getProductId())))
                .collect(Collectors.toList());
    }

    @Override
    public Page<ProductResponse> searchProducts(String shopId, String branchId, String keyword, Pageable pageable) {
        if (!StringUtils.hasText(keyword)) {
            // If no keyword, return all products by shop/branch
            return productCache.getAllByShop(shopId, branchId, pageable);
        }

        // 1. Search for matching master Products by keyword
        List<Product> matchedProductsByName = productRepository.findByShopIdAndNameContainingIgnoreCaseAndDeletedFalse(shopId, keyword).stream().toList();
        List<Product> matchedProductsByCategory = productRepository.findByShopIdAndCategoryContainingIgnoreCaseAndDeletedFalse(shopId, keyword).stream().toList();

        // Combine unique product IDs
        Set<String> productIdsFromKeyword = matchedProductsByName.stream()
                .map(Product::getId)
                .collect(Collectors.toSet());
        matchedProductsByCategory.forEach(p -> productIdsFromKeyword.add(p.getId()));

        if (productIdsFromKeyword.isEmpty()) {
            return new PageImpl<>(List.of(), pageable, 0); // No master products matched
        }

        // 2. Fetch BranchProducts associated with these master Product IDs, filtering by branchId
        Page<BranchProduct> branchProductsPage;
        if (StringUtils.hasText(branchId)) {
            branchProductsPage = branchProductRepository.findByProductIdInAndShopIdAndBranchIdAndDeletedFalse(productIdsFromKeyword, shopId, branchId, pageable);
        } else {
            branchProductsPage = branchProductRepository.findByProductIdInAndShopIdAndDeletedFalse(productIdsFromKeyword, shopId, pageable);
        }

        // 3. Re-fetch all master Products for the current page of BranchProducts
        // This ensures we have the master product details for response mapping
        Set<String> currentPageProductIds = branchProductsPage.getContent().stream()
                .map(BranchProduct::getProductId)
                .collect(Collectors.toSet());
        Map<String, Product> productsMap = productRepository.findAllById(currentPageProductIds).stream()
                .collect(Collectors.toMap(Product::getId, Function.identity()));

        // 4. Map to ProductResponse
        List<ProductResponse> productResponses = branchProductsPage.getContent().stream()
                .map(bp -> toResponse(bp, productsMap.get(bp.getProductId())))
                .collect(Collectors.toList());

        return new PageImpl<>(productResponses, pageable, branchProductsPage.getTotalElements());
    }

    public ProductResponse toResponse(BranchProduct branchProduct, Product product) {
        if (branchProduct == null || product == null) {
            return null; // Handle cases where product might be null (e.g., deleted master product)
        }
        return ProductResponse.builder()
                .id(branchProduct.getId()) // ID của BranchProduct
                .productId(product.getId()) // ID của Master Product
                .name(product.getName())
                .category(product.getCategory())
                .sku(product.getSku())
                .quantity(branchProduct.getQuantity())
                .price(branchProduct.getPrice())
                .unit(branchProduct.getUnit())
                .imageUrl(branchProduct.getImageUrl())
                .description(branchProduct.getDescription())
                .branchId(branchProduct.getBranchId())
                .activeInBranch(branchProduct.isActiveInBranch())
                .createdAt(branchProduct.getCreatedAt()) // createdAt/updatedAt của BranchProduct
                .updatedAt(branchProduct.getUpdatedAt())
                .build();
    }

    private boolean requiresInventory(ShopType type) {
        return switch (type) {
            case GROCERY, CONVENIENCE, PHARMACY, RETAIL -> true;
            case RESTAURANT, CAFE, BAR, OTHER -> false;
        };
    }
}

// File: src/main/java/com/example/sales/service/ExcelImportService.java
package com.example.sales.service;

import java.io.InputStream;

public interface ExcelImportService {
    /**
     * Nhập sản phẩm từ file Excel vào một chi nhánh cụ thể của một cửa hàng.
     * Mỗi dòng trong file Excel sẽ tạo/cập nhật một BranchProduct và định nghĩa Product chung nếu cần.
     *
     * @param shopId ID của cửa hàng.
     * @param branchId ID của chi nhánh mà sản phẩm sẽ được nhập vào.
     * @param inputStream InputStream của file Excel.
     * @return Số lượng sản phẩm (BranchProduct) được nhập/cập nhật thành công.
     */
    int importProducts(String shopId, String branchId, InputStream inputStream);
}

// File: src/main/java/com/example/sales/service/impl/ExcelImportServiceImpl.java
package com.example.sales.service.impl;

import com.example.sales.constant.ApiCode;
import com.example.sales.exception.BusinessException;
import com.example.sales.model.BranchProduct;
import com.example.sales.model.Product;
import com.example.sales.repository.BranchProductRepository;
import com.example.sales.repository.ProductRepository;
import com.example.sales.service.ExcelImportService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.poi.ss.usermodel.*;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.io.IOException;
import java.io.InputStream;
import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class ExcelImportServiceImpl implements ExcelImportService {

    private final ProductRepository productRepository;
    private final BranchProductRepository branchProductRepository;

    @Override
    @Transactional
    public int importProducts(String shopId, String branchId, InputStream inputStream) {
        int importedCount = 0;
        try (Workbook workbook = WorkbookFactory.create(inputStream)) {
            Sheet sheet = workbook.getSheetAt(0); // Lấy sheet đầu tiên

            // Bỏ qua hàng tiêu đề
            for (int i = 1; i <= sheet.getLastRowNum(); i++) {
                Row row = sheet.getRow(i);
                if (row == null) continue;

                try {
                    // Đọc dữ liệu từ các cột
                    String sku = getCellValue(row.getCell(0)); // Giả định SKU ở cột 0
                    String name = getCellValue(row.getCell(1)); // Giả định Tên ở cột 1
                    String category = getCellValue(row.getCell(2)); // Giả định Danh mục ở cột 2
                    String unit = getCellValue(row.getCell(3)); // Giả định Đơn vị ở cột 3
                    double price = getNumericCellValue(row.getCell(4)); // Giả định Giá ở cột 4
                    int quantity = (int) getNumericCellValue(row.getCell(5)); // Giả định Số lượng ở cột 5
                    String imageUrl = getCellValue(row.getCell(6)); // Giả định Ảnh ở cột 6
                    String description = getCellValue(row.getCell(7)); // Giả định Mô tả ở cột 7

                    if (!StringUtils.hasText(sku) || !StringUtils.hasText(name) || !StringUtils.hasText(category) || !StringUtils.hasText(unit)) {
                        log.warn("Bỏ qua dòng {}: Thiếu SKU, tên, danh mục hoặc đơn vị.", i + 1);
                        continue;
                    }

                    // 1. Tìm hoặc tạo Product (định nghĩa chung)
                    Optional<Product> existingProduct = productRepository.findByShopIdAndSkuAndDeletedFalse(shopId, sku);
                    Product product;
                    if (existingProduct.isPresent()) {
                        product = existingProduct.get();
                        // Cập nhật thông tin chung nếu có thay đổi
                        product.setName(name);
                        product.setCategory(category);
                        productRepository.save(product);
                    } else {
                        product = Product.builder()
                                .shopId(shopId)
                                .name(name)
                                .category(category)
                                .sku(sku)
                                .build();
                        product = productRepository.save(product);
                    }

                    // 2. Tạo hoặc cập nhật BranchProduct
                    Optional<BranchProduct> existingBranchProduct = branchProductRepository.findByProductIdAndBranchIdAndDeletedFalse(product.getId(), branchId);
                    BranchProduct branchProduct;
                    if (existingBranchProduct.isPresent()) {
                        branchProduct = existingBranchProduct.get();
                        branchProduct.setQuantity(quantity);
                        branchProduct.setPrice(price);
                        branchProduct.setUnit(unit);
                        branchProduct.setImageUrl(imageUrl);
                        branchProduct.setDescription(description);
                        branchProduct.setActiveInBranch(true); // Mặc định kích hoạt khi nhập
                        branchProductRepository.save(branchProduct);
                        log.info("Cập nhật BranchProduct cho SKU '{}' tại chi nhánh '{}'", sku, branchId);
                    } else {
                        branchProduct = BranchProduct.builder()
                                .productId(product.getId())
                                .shopId(shopId)
                                .branchId(branchId)
                                .quantity(quantity)
                                .price(price)
                                .unit(unit)
                                .imageUrl(imageUrl)
                                .description(description)
                                .activeInBranch(true) // Mặc định kích hoạt khi nhập
                                .build();
                        branchProductRepository.save(branchProduct);
                        log.info("Tạo mới BranchProduct cho SKU '{}' tại chi nhánh '{}'", sku, branchId);
                    }
                    importedCount++;
                } catch (Exception e) {
                    log.error("Lỗi khi xử lý dòng {}: {}", i + 1, e.getMessage());
                    // Có thể throw BusinessException hoặc thu thập các lỗi để trả về thông báo chi tiết
                }
            }
        } catch (IOException e) {
            log.error("Lỗi đọc file Excel: {}", e.getMessage());
            throw new BusinessException(ApiCode.VALIDATION_ERROR);
        }
        return importedCount;
    }

    private String getCellValue(Cell cell) {
        if (cell == null) {
            return null;
        }
        return switch (cell.getCellType()) {
            case STRING -> cell.getStringCellValue();
            case NUMERIC -> String.valueOf((long) cell.getNumericCellValue()); // For numeric cells that should be string (e.g., SKU if it's numeric)
            case BOOLEAN -> String.valueOf(cell.getBooleanCellValue());
            case FORMULA -> cell.getCellFormula();
            case BLANK -> null;
            default -> null;
        };
    }

    private double getNumericCellValue(Cell cell) {
        if (cell == null || cell.getCellType() == CellType.BLANK) {
            return 0.0;
        }
        if (cell.getCellType() == CellType.NUMERIC) {
            return cell.getNumericCellValue();
        }
        if (cell.getCellType() == CellType.STRING) {
            try {
                return Double.parseDouble(cell.getStringCellValue());
            } catch (NumberFormatException e) {
                return 0.0; // Hoặc throw exception nếu giá trị không hợp lệ
            }
        }
        return 0.0;
    }
}

// File: src/main/java/com/example/sales/service/impl/InventoryServiceImpl.java
package com.example.sales.service.impl;

import com.example.sales.constant.ApiCode;
import com.example.sales.constant.InventoryType;
import com.example.sales.dto.inventory.InventoryTransactionResponse;
import com.example.sales.exception.BusinessException;
import com.example.sales.exception.ResourceNotFoundException;
import com.example.sales.model.BranchProduct;
import com.example.sales.model.InventoryTransaction;
import com.example.sales.model.Product;
import com.example.sales.model.Shop;
import com.example.sales.repository.BranchProductRepository;
import com.example.sales.repository.InventoryTransactionRepository;
import com.example.sales.repository.ProductRepository;
import com.example.sales.repository.ShopRepository;
import com.example.sales.service.AuditLogService;
import com.example.sales.service.InventoryService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
@Slf4j
public class InventoryServiceImpl implements InventoryService {

    private final BranchProductRepository branchProductRepository;
    private final ProductRepository productRepository; // Để lấy tên sản phẩm cho audit/log
    private final InventoryTransactionRepository inventoryTransactionRepository;
    private final ShopRepository shopRepository;
    private final AuditLogService auditLogService;

    @Override
    @Transactional
    public int importProductQuantity(String userId, String shopId, String branchId, String branchProductId, int quantity, String note) {
        if (quantity <= 0) {
            throw new BusinessException(ApiCode.VALIDATION_ERROR);
        }

        if (!isInventoryManagementRequired(shopId)) {
            log.info("Cửa hàng {} không yêu cầu quản lý tồn kho. Bỏ qua thao tác nhập.", shopId);
            return -1; // Hoặc trả về số lượng hiện tại nếu muốn
        }

        BranchProduct branchProduct = findBranchProduct(shopId, branchId, branchProductId);
        int oldQuantity = branchProduct.getQuantity();
        branchProduct.setQuantity(oldQuantity + quantity);
        branchProductRepository.save(branchProduct);

        Product masterProduct = getMasterProduct(branchProduct.getProductId(), shopId);

        saveInventoryTransaction(
                userId, shopId, branchId, branchProduct.getId(),
                masterProduct.getName(), InventoryType.IMPORT, quantity, branchProduct.getQuantity(),
                note, null
        );

        auditLogService.log(userId, shopId, branchProduct.getId(), "BRANCH_PRODUCT", "INVENTORY_IMPORT",
                String.format("Nhập thêm %d đơn vị sản phẩm '%s' (SKU: %s) vào chi nhánh %s. Tồn kho cũ: %d, Tồn kho mới: %d.",
                        quantity, masterProduct.getName(), masterProduct.getSku(), branchId, oldQuantity, branchProduct.getQuantity()));

        log.info("Nhập thành công {} sản phẩm '{}' cho chi nhánh {}. Số lượng mới: {}",
                quantity, masterProduct.getName(), branchId, branchProduct.getQuantity());

        return branchProduct.getQuantity();
    }

    @Override
    @Transactional
    public int exportProductQuantity(String userId, String shopId, String branchId, String branchProductId, int quantity, String note, String referenceId) {
        if (quantity <= 0) {
            throw new BusinessException(ApiCode.VALIDATION_ERROR);
        }

        if (!isInventoryManagementRequired(shopId)) {
            log.info("Cửa hàng {} không yêu cầu quản lý tồn kho. Bỏ qua thao tác xuất.", shopId);
            return -1;
        }

        BranchProduct branchProduct = findBranchProduct(shopId, branchId, branchProductId);
        int oldQuantity = branchProduct.getQuantity();

        if (oldQuantity < quantity) {
            log.warn("Không đủ tồn kho để xuất. Số lượng hiện tại: {}, Số lượng yêu cầu: {}", oldQuantity, quantity);
            throw new BusinessException(ApiCode.INSUFFICIENT_STOCK);
        }

        branchProduct.setQuantity(oldQuantity - quantity);
        branchProductRepository.save(branchProduct);

        Product masterProduct = getMasterProduct(branchProduct.getProductId(), shopId);

        saveInventoryTransaction(
                userId, shopId, branchId, branchProduct.getId(),
                masterProduct.getName(), InventoryType.EXPORT, quantity, branchProduct.getQuantity(),
                note, referenceId
        );

        auditLogService.log(userId, shopId, branchProduct.getId(), "BRANCH_PRODUCT", "INVENTORY_EXPORT",
                String.format("Xuất %d đơn vị sản phẩm '%s' (SKU: %s) khỏi chi nhánh %s. Tồn kho cũ: %d, Tồn kho mới: %d. Tham chiếu: %s.",
                        quantity, masterProduct.getName(), masterProduct.getSku(), branchId, oldQuantity, branchProduct.getQuantity(), referenceId));

        log.info("Xuất thành công {} sản phẩm '{}' cho chi nhánh {}. Số lượng mới: {}",
                quantity, masterProduct.getName(), branchId, branchProduct.getQuantity());

        return branchProduct.getQuantity();
    }

    @Override
    @Transactional
    public int adjustProductQuantity(String userId, String shopId, String branchId, String branchProductId, int newQuantity, String note) {
        if (newQuantity < 0) {
            throw new BusinessException(ApiCode.VALIDATION_ERROR);
        }

        if (!isInventoryManagementRequired(shopId)) {
            log.info("Cửa hàng {} không yêu cầu quản lý tồn kho. Bỏ qua thao tác điều chỉnh.", shopId);
            return -1;
        }

        BranchProduct branchProduct = findBranchProduct(shopId, branchId, branchProductId);
        int oldQuantity = branchProduct.getQuantity();
        int quantityChange = newQuantity - oldQuantity; // Số lượng thay đổi (có thể âm hoặc dương)

        branchProduct.setQuantity(newQuantity);
        branchProductRepository.save(branchProduct);

        Product masterProduct = getMasterProduct(branchProduct.getProductId(), shopId);

        saveInventoryTransaction(
                userId, shopId, branchId, branchProduct.getId(),
                masterProduct.getName(), InventoryType.ADJUSTMENT, quantityChange, branchProduct.getQuantity(),
                note, null
        );

        auditLogService.log(userId, shopId, branchProduct.getId(), "BRANCH_PRODUCT", "INVENTORY_ADJUSTMENT",
                String.format("Điều chỉnh tồn kho sản phẩm '%s' (SKU: %s) tại chi nhánh %s từ %d thành %d. Thay đổi: %s%d.",
                        masterProduct.getName(), masterProduct.getSku(), branchId, oldQuantity, newQuantity, quantityChange > 0 ? "+" : "", quantityChange));

        log.info("Điều chỉnh tồn kho sản phẩm '{}' cho chi nhánh {}. Số lượng cũ: {}, Số lượng mới: {}",
                masterProduct.getName(), branchId, oldQuantity, newQuantity);

        return branchProduct.getQuantity();
    }

    @Override
    public Page<InventoryTransactionResponse> getTransactionHistory(String userId, String shopId, String branchId, String branchProductId, Pageable pageable) {
        auditLogService.log(userId, shopId, branchProductId, "BRANCH_PRODUCT", "INVENTORY_HISTORY_VIEW",
                String.format("Lấy lịch sử giao dịch tồn kho cho sản phẩm '%s' tại chi nhánh %s.", branchProductId, branchId));
        return inventoryTransactionRepository.findByProductIdOrderByCreatedAtDesc(branchProductId, pageable)
                .map(this::mapToInventoryTransactionResponse);
    }

    @Override
    public boolean isInventoryManagementRequired(String shopId) {
        Shop shop = shopRepository.findByIdAndDeletedFalse(shopId)
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.SHOP_NOT_FOUND));
        return !shop.getType().isTrackInventory(); // Ví dụ: Cửa hàng dịch vụ không quản lý tồn kho
    }

    private BranchProduct findBranchProduct(String shopId, String branchId, String branchProductId) {
        return branchProductRepository.findByIdAndShopIdAndBranchIdAndDeletedFalse(branchProductId, shopId, branchId)
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.PRODUCT_NOT_FOUND));
    }

    private Product getMasterProduct(String productId, String shopId) {
        return productRepository.findByIdAndShopIdAndDeletedFalse(productId, shopId)
                .orElseThrow(() -> new ResourceNotFoundException(ApiCode.PRODUCT_NOT_FOUND));
    }

    private void saveInventoryTransaction(
            String userId, String shopId, String branchId, String branchProductId,
            String productName, InventoryType type, int quantity, int currentStock, String note, String referenceId) {

        InventoryTransaction transaction = InventoryTransaction.builder()
                .shopId(shopId)
                .branchId(branchId)
                .productId(branchProductId)
                .type(type)
                .quantity(quantity)
                .note(note)
                .referenceId(referenceId)
                .build();
        inventoryTransactionRepository.save(transaction);
    }

    private InventoryTransactionResponse mapToInventoryTransactionResponse(InventoryTransaction transaction) {
        // Tùy thuộc vào cách bạn muốn hiển thị Product name trong response,
        // có thể cần fetch Product master ở đây hoặc Product name đã được lưu trong transaction
        // Hiện tại, giả định InventoryTransaction chỉ lưu productId, cần fetch Product.name
        String productName = "Unknown Product";
        try {
            // Lấy ID của Product master từ BranchProduct ID trong transaction
            BranchProduct branchProduct = branchProductRepository.findById(transaction.getProductId()).orElse(null);
            if (branchProduct != null) {
                Product masterProduct = productRepository.findById(branchProduct.getProductId()).orElse(null);
                if (masterProduct != null) {
                    productName = masterProduct.getName();
                }
            }
        } catch (Exception e) {
            log.warn("Could not resolve product name for transaction: {}", transaction.getId(), e);
        }

        return InventoryTransactionResponse.builder()
                .id(transaction.getId())
                .shopId(transaction.getShopId())
                .branchId(transaction.getBranchId())
                .branchProductId(transaction.getProductId()) // Đây là branchProductId
                .productName(productName)
                .type(transaction.getType())
                .quantity(transaction.getQuantity())
                .note(transaction.getNote())
                .referenceId(transaction.getReferenceId())
                .createdAt(transaction.getCreatedAt())
                .createdBy(transaction.getCreatedBy())
                .build();
    }
}
[END]